{"ast":null,"code":"// /* Gamepad class */\n// class ThreeScene extends Component {\n//     componentDidMount() {\nconst Gamepad = class {\n  constructor(options) {\n    options = options || {}; // set the managers\n\n    this.worker = new Gamepad.Worker();\n    this.blocklyManager = new Gamepad.BlocklyManager(options);\n    this.jsonManager = new Gamepad.JsonManager();\n    this['magicJson'] = options['magicJson'] === true;\n    this['highlight'] = options['customHighlight'] !== undefined;\n    this.reset();\n    this.worker.onRequest(this, this.onRequest);\n  } // level getter\n\n\n  get level() {\n    return this.jsonManager.observer;\n  } // level setter\n\n\n  set level(level) {\n    this.jsonManager.init([level]);\n  } // levels getter\n\n\n  get levels() {\n    return this.jsonManager.observers;\n  } // levels setter\n\n\n  set levels(levels) {\n    if (!Array.isArray(levels)) throw new Error('levels argument must be an array');\n    this.jsonManager.init(levels);\n  } // worker requests's handler\n\n\n  onRequest(request, back, old) {\n    // if the workspace has changed since the last time the code was loaded\n    // the block is not highlighted\n    if (!this.blocklyManager.isCoding && this.highlight) this.blocklyManager.setHighlight(request.id); // if the current level is finished and there's a forward 'START' request (must be forward) the next level is loaded\n    // if there's only one level this method is never triggered\n\n    if (request.method == Gamepad['STATES']['STARTED'] && (this.state == Gamepad['STATES']['FINISHED'] || this.state == Gamepad['STATES']['COMPLETED']) && !back) this.jsonManager.loadNext(); // if the current level is started and there's a 'FINISHED' request (must be backward) the prior level is loaded\n    // if there's only one level this method is never triggered\n\n    if ((request.method == Gamepad['STATES']['FINISHED'] || request.method == Gamepad['STATES']['COMPLETED']) && this.state == Gamepad['STATES']['STARTED'] && back) this.jsonManager.loadPrior(); // if the request is not old and magicJson is enabled\n\n    if (this['magicJson'] && old) {\n      // if it's a backward request\n      if (back) // unload the changes\n        this.jsonManager.unloadChanges(); // if this is a forward request\n      else // load the changes\n        this.jsonManager.loadChanges();\n    } // send the request to the game\n\n\n    let result = this.game(request, back, old); // update the state \n\n    if (request.method == Gamepad['STATES']['STARTED'] || request.method == Gamepad['STATES']['FINISHED'] || request.method == Gamepad['STATES']['COMPLETED']) this.state = request.method; // if there's the json manager and the request is not old the changes are saved\n\n    if (this['magicJson'] && !old) this.jsonManager.commit(); // return the game result\n\n    return result;\n  } // set the requests's handler\n\n\n  setGame(thisArg, method) {\n    // it must be a function\n    if (typeof method != 'function') throw new Error('method is not a function');\n\n    this.game = function () {\n      return method.apply(thisArg, [...arguments]);\n    };\n  } // load the code n times\n\n\n  load(times) {\n    // reset the state of the game\n    this.state = Gamepad['STATES']['STARTED']; // if times is setted it must be a number greater than 0\n\n    if (times !== undefined && (isNaN(times) || times < 1)) throw new Error('times must be a number greater than 0.'); // if times is not setted load code 1 times\n\n    times = times || 1; // reset the workspace\n\n    this.worker.reset(); // get the code\n\n    let code = this.blocklyManager.code(times); // reset the jsonManager\n\n    this.jsonManager.reset(); // load the code\n\n    Gamepad.evalContext(code, this.worker.getInstance()); // return the blocks number\n\n    return this.blocklyManager.getBlocksNumber();\n  } // reset the gamepad\n\n\n  reset() {\n    // reset the state of the game\n    this.state = Gamepad['STATES']['STARTED']; // reset the jsonManager\n\n    this.jsonManager.reset(); // reset the worker\n\n    this.worker.reset(); // reset the blocklyManager\n\n    this.blocklyManager.reset();\n  } // update the toolbox\n\n\n  setToolbox(options) {\n    this.blocklyManager.setToolbox(options);\n  } // generate a forward request\n\n\n  forward() {\n    // stop the worker if it was running\n    this.worker.stop(); // send a forward request\n\n    return this.worker.go(false);\n  } // create a backward request\n\n\n  backward() {\n    // stop the worker if it was running\n    this.worker.stop(); // send a backward request\n\n    return this.worker.go(true);\n  } // play the game (back ? backward : forward)\n\n\n  play(back) {\n    // remove the breakpoint\n    this.worker.removeBreakpoint(); // free the queue of requests\n\n    this.worker.freeQueue(); // start the worker\n\n    this.worker.start(back);\n  } // pause the game\n\n\n  pause() {\n    // stop the worker\n    this.worker.stop(); // free the queue of requests\n\n    this.worker.freeQueue();\n  } // toggle play\n\n\n  togglePlay() {\n    if (this.worker.isRunning) this.pause();else this.play(this.worker.back);\n  } // reach a breakpoint\n\n\n  debug(id, back) {\n    let promise = this.worker.setBreakpoint(id);\n    this.worker.start(back);\n    return promise;\n  } // save the workspace\n\n\n  save(name) {\n    this.blocklyManager.save(name);\n  } // restore the workspace\n\n\n  restore(name) {\n    this.blocklyManager.restore(name);\n  } // version\n\n\n  static version() {\n    return '1.0.1';\n  }\n\n};\n/* Gamepad symbol */\n// a global symbol (used in Observer and Asynchronizer classes)\n\nGamepad['SYMBOL'] = Symbol('blockly-gamepad');\n/* Gamebad toolbox */\n// will contain a json that represent the toolbox\n\nGamepad['TOOLBOX'] = {};\n/* Gamebad context */\n// global context that the code generator can access\n\nGamepad['CONTEXT'] = {};\n/* Gamebad inputs */\n// will contain some inputs\n\nGamepad['INPUTS'] = {};\n/* Gamepad errors */\n// strings that represents errors\n\nGamepad['ERRORS'] = {\n  // this error means that the instance that throw it has been resetted\n  // used by Asynchronizer and the Queue\n  'CLOSED': 'CLOSED',\n  // this error is throwed by the Worker to end a level\n  'FINISHED': 'FINISHED',\n  // this error is throwed by the Worker to end all the levels\n  'COMPLETED': 'COMPLETED'\n};\n/* Gamepad states */\n// states are passed in the request .method field\n\nGamepad['STATES'] = {\n  // a level is started\n  'STARTED': 'STARTED',\n  // a level is finished\n  'FINISHED': 'FINISHED',\n  // all the levels are finished\n  'COMPLETED': 'COMPLETED'\n};\n/* Gamepad blocks */\n\nGamepad['BLOCKS'] = {\n  // the type of the start block\n  'START': 'start'\n};\n/* Gamepad templates */\n// templates are used to generate custom blocks\n\nGamepad['TEMPLATES'] = {\n  'WHILE': 'while',\n  'DO_WHILE': 'do_while',\n  'IF': 'if',\n  'IF_ELSE': 'if_else'\n};\n/* Gamepad utils */\n\nGamepad.utils = {\n  /* xml to json */\n  xml2json: function (xml, tab) {\n    var X = {\n      toObj: function (xml) {\n        var o = {};\n\n        if (xml.nodeType == 1) {\n          if (xml.attributes.length) for (var i = 0; i < xml.attributes.length; i++) o[\"@\" + xml.attributes[i].nodeName] = (xml.attributes[i].nodeValue || \"\").toString();\n\n          if (xml.firstChild) {\n            var textChild = 0,\n                cdataChild = 0,\n                hasElementChild = false;\n\n            for (var n = xml.firstChild; n; n = n.nextSibling) {\n              if (n.nodeType == 1) hasElementChild = true;else if (n.nodeType == 3 && n.nodeValue.match(/[^ \\f\\n\\r\\t\\v]/)) textChild++;else if (n.nodeType == 4) cdataChild++;\n            }\n\n            if (hasElementChild) {\n              if (textChild < 2 && cdataChild < 2) {\n                X.removeWhite(xml);\n\n                for (var n = xml.firstChild; n; n = n.nextSibling) {\n                  if (n.nodeType == 3) o[\"#text\"] = X.escape(n.nodeValue);else if (n.nodeType == 4) o[\"#cdata\"] = X.escape(n.nodeValue);else if (o[n.nodeName]) {\n                    if (o[n.nodeName] instanceof Array) o[n.nodeName][o[n.nodeName].length] = X.toObj(n);else o[n.nodeName] = [o[n.nodeName], X.toObj(n)];\n                  } else o[n.nodeName] = X.toObj(n);\n                }\n              } else {\n                if (!xml.attributes.length) o = X.escape(X.innerXml(xml));else o[\"#text\"] = X.escape(X.innerXml(xml));\n              }\n            } else if (textChild) {\n              if (!xml.attributes.length) o = X.escape(X.innerXml(xml));else o[\"#text\"] = X.escape(X.innerXml(xml));\n            } else if (cdataChild) {\n              if (cdataChild > 1) o = X.escape(X.innerXml(xml));else for (var n = xml.firstChild; n; n = n.nextSibling) o[\"#cdata\"] = X.escape(n.nodeValue);\n            }\n          }\n\n          if (!xml.attributes.length && !xml.firstChild) o = null;\n        } else if (xml.nodeType == 9) {\n          o = X.toObj(xml.documentElement);\n        }\n\n        return o;\n      },\n      toJson: function (o, name, ind) {\n        var json = name ? \"\\\"\" + name + \"\\\"\" : \"\";\n\n        if (o instanceof Array) {\n          for (var i = 0, n = o.length; i < n; i++) o[i] = X.toJson(o[i], \"\", ind + \"\\t\");\n\n          json += (name ? \":[\" : \"[\") + (o.length > 1 ? \"\\n\" + ind + \"\\t\" + o.join(\",\\n\" + ind + \"\\t\") + \"\\n\" + ind : o.join(\"\")) + \"]\";\n        } else if (o == null) json += (name && \":\") + \"null\";else if (typeof o == \"object\") {\n          var arr = [];\n\n          for (var m in o) arr[arr.length] = X.toJson(o[m], m, ind + \"\\t\");\n\n          json += (name ? \":{\" : \"{\") + (arr.length > 1 ? \"\\n\" + ind + \"\\t\" + arr.join(\",\\n\" + ind + \"\\t\") + \"\\n\" + ind : arr.join(\"\")) + \"}\";\n        } else if (typeof o == \"string\") json += (name && \":\") + \"\\\"\" + o.toString() + \"\\\"\";else json += (name && \":\") + o.toString();\n\n        return json;\n      },\n      innerXml: function (node) {\n        var s = \"\";\n        if (\"innerHTML\" in node) s = node.innerHTML;else {\n          var asXml = function (n) {\n            var s = \"\";\n\n            if (n.nodeType == 1) {\n              s += \"<\" + n.nodeName;\n\n              for (var i = 0; i < n.attributes.length; i++) s += \" \" + n.attributes[i].nodeName + \"=\\\"\" + (n.attributes[i].nodeValue || \"\").toString() + \"\\\"\";\n\n              if (n.firstChild) {\n                s += \">\";\n\n                for (var c = n.firstChild; c; c = c.nextSibling) s += asXml(c);\n\n                s += \"</\" + n.nodeName + \">\";\n              } else s += \"/>\";\n            } else if (n.nodeType == 3) s += n.nodeValue;else if (n.nodeType == 4) s += \"<![CDATA[\" + n.nodeValue + \"]]>\";\n\n            return s;\n          };\n\n          for (var c = node.firstChild; c; c = c.nextSibling) s += asXml(c);\n        }\n        return s;\n      },\n      escape: function (txt) {\n        return txt.replace(/[\\\\]/g, \"\\\\\\\\\").replace(/[\\\"]/g, '\\\\\"').replace(/[\\n]/g, '\\\\n').replace(/[\\r]/g, '\\\\r');\n      },\n      removeWhite: function (e) {\n        e.normalize();\n\n        for (var n = e.firstChild; n;) {\n          if (n.nodeType == 3) {\n            if (!n.nodeValue.match(/[^ \\f\\n\\r\\t\\v]/)) {\n              var nxt = n.nextSibling;\n              e.removeChild(n);\n              n = nxt;\n            } else n = n.nextSibling;\n          } else if (n.nodeType == 1) {\n            X.removeWhite(n);\n            n = n.nextSibling;\n          } else n = n.nextSibling;\n        }\n\n        return e;\n      }\n    };\n    if (xml.nodeType == 9) xml = xml.documentElement;\n    var json = X.toJson(X.toObj(X.removeWhite(xml)), xml.nodeName, \"\\t\");\n    return \"{\\n\" + tab + (tab ? json.replace(/\\t/g, tab) : json.replace(/\\t|\\n/g, \"\")) + \"\\n}\";\n  },\n\n  /* json to xml */\n  json2xml: function (o, tab) {\n    var toXml = function (v, name, ind) {\n      var xml = \"\";\n\n      if (v instanceof Array) {\n        for (var i = 0, n = v.length; i < n; i++) xml += ind + toXml(v[i], name, ind + \"\\t\") + \"\\n\";\n      } else if (typeof v == \"object\") {\n        var hasChild = false;\n        xml += ind + \"<\" + name.toLowerCase();\n\n        for (var m in v) {\n          if (m.charAt(0) == \"@\") xml += \" \" + m.substr(1) + \"=\\\"\" + v[m].toString() + \"\\\"\";else hasChild = true;\n        }\n\n        xml += hasChild ? \">\" : \"/>\";\n\n        if (hasChild) {\n          for (var m in v) {\n            if (m == \"#text\") xml += v[m];else if (m == \"#cdata\") xml += \"<![CDATA[\" + v[m] + \"]]>\";else if (m.charAt(0) != \"@\") xml += toXml(v[m], m, ind + \"\\t\");\n          }\n\n          xml += (xml.charAt(xml.length - 1) == \"\\n\" ? ind : \"\") + \"</\" + name.toLowerCase() + \">\";\n        }\n      } else {\n        xml += ind + \"<\" + name + \">\" + v.toString() + \"</\" + name + \">\";\n      }\n\n      return xml;\n    },\n        xml = \"\";\n\n    for (var m in o) xml += toXml(o[m], m.toString().toLowerCase(), \"\");\n\n    return tab ? xml.replace(/\\t/g, tab) : xml.replace(/\\t|\\n/g, \"\");\n  },\n\n  /* filter the toolbox json */\n  filter: function (json, options) {\n    let hasCategory = false,\n        hasBlock = false; // show/hide PROCEDURE custom category\n\n    if (json['@custom'] == \"PROCEDURE\") {\n      return options.procedure !== false;\n    } // show/hide VARIABLE custom category\n\n\n    if (json['@custom'] == \"VARIABLE\") {\n      return options.variable !== false;\n    }\n\n    if (json.CATEGORY) {\n      let i;\n\n      for (i = 0; i < json.CATEGORY.length; i++) {\n        if (!Gamepad.utils.filter(json.CATEGORY[i], options)) {\n          json.CATEGORY.splice(i, 1);\n          i--;\n        }\n      } // there's at least one category\n\n\n      if (i > 0) hasCategory = true;\n    }\n\n    if (json.BLOCK) {\n      let i;\n\n      for (i = 0; i < json.BLOCK.length; i++) {\n        // if the block has to be visualized\n        if (!options.blocks.includes(json.BLOCK[i]['@type'])) {\n          json.BLOCK.splice(i, 1);\n          i--;\n        }\n      } // there's at least one block\n\n\n      if (i > 0) hasBlock = true;\n    } // there's something to render in the toolbox\n\n\n    return hasCategory || hasBlock;\n  },\n\n  /* block generator */\n  blocks: function (blocks) {\n    let jsonArray = [];\n\n    for (let type in blocks) {\n      let block = blocks[type],\n          hasStatements = false,\n          hastemplate = false;\n\n      if ('statements' in block) {\n        // statements must be an array of string\n        if (!Array.isArray(block.statements) || block.statements.length == 0) throw new Error('statements must be an array of string');\n        hasStatements = true;\n      }\n\n      if ('template' in block) {\n        // template must be one of the Gamepad['TEMPLATES']\n        if (!Object.values(Gamepad['TEMPLATES']).includes(block.template)) throw new Error('template must be one of Gamepad[\\'TEMPLATES\\']');\n        hastemplate = true;\n      } // a block must have both or none\n\n\n      if (hastemplate && !hasStatements) throw new Error('a template block require at least a statement');\n      if (!hastemplate && hasStatements) throw new Error('statements setted without the template'); // load the javascript\n\n      Blockly.JavaScript['' + type] = Gamepad.utils.js(block.method, block.args, block.order, block.template, block.statements); // init the block with the json or the javascript\n\n      if ('json' in block) {\n        block.json.type = type;\n        jsonArray.push(block.json);\n      } else if ('javascript' in block) {\n        Blockly.Blocks[type] = block.javascript;\n      }\n    }\n\n    Blockly.defineBlocksWithJsonArray(jsonArray);\n  },\n\n  /* wrap standard blocks to generate requests */\n  wrap: function (blocks) {\n    if (!Array.isArray(blocks)) throw new Error('blocks must be an array of block types');\n\n    for (let type of blocks) {\n      if (!(type in Blockly.JavaScript)) throw new Error('The following type does not exist: ' + type);\n      let oldGenerator = Blockly.JavaScript[type];\n\n      switch (type) {\n        // procedures wrap\n        case 'procedures_defnoreturn':\n          ;\n\n        case 'procedures_defreturn':\n          Blockly.JavaScript[type] = function (a) {\n            var b = Blockly.JavaScript.variableDB_.getName(a.getFieldValue(\"NAME\"), Blockly.Procedures.NAME_TYPE),\n                c = Blockly.JavaScript.statementToCode(a, \"STACK\");\n\n            if (Blockly.JavaScript.STATEMENT_PREFIX) {\n              var d = a.id.replace(/\\$/g, \"$$$$\");\n              c = Blockly.JavaScript.prefixLines(Blockly.JavaScript.STATEMENT_PREFIX.replace(/%1/g, \"'\" + d + \"'\"), Blockly.JavaScript.INDENT) + c;\n            }\n\n            Blockly.JavaScript.INFINITE_LOOP_TRAP && (c = Blockly.JavaScript.INFINITE_LOOP_TRAP.replace(/%1/g, \"'\" + a.id + \"'\") + c);\n            (d = Blockly.JavaScript.valueToCode(a, \"RETURN\", Blockly.JavaScript.ORDER_NONE) || \"\") && (d = Blockly.JavaScript.INDENT + \"return \" + d + \";\\n\");\n\n            for (var e = [], f = 0; f < a.arguments_.length; f++) e[f] = Blockly.JavaScript.variableDB_.getName(a.arguments_[f], Blockly.Variables.NAME_TYPE);\n\n            c = \"async function \" + b + \"(\" + e.join(\", \") + \") {\\n\" + Gamepad.utils.request(type, [b], a.id) + c + d + \"\\n\" + \"}\";\n            c = Blockly.JavaScript.scrub_(a, c);\n            Blockly.JavaScript.definitions_[\"%\" + b] = c;\n            return null;\n          };\n\n          break;\n        // default wrap\n\n        default:\n          Blockly.JavaScript[type] = function (block) {\n            let result = oldGenerator.apply(this, [...arguments]),\n                request = Gamepad.utils.request(type, [], block.id); // if there's a order\n\n            Array.isArray(result) ? result[0] = request.slice(0, -1) + '.then(async () => ' + result[0] + ' )\\n' : result = request + result;\n            return result;\n          };\n\n      }\n    }\n  },\n\n  /* build a request object */\n  build: function (method, args, id, data) {\n    // check the arguments\n    if (typeof method != 'string') method = '';\n    if (!Array.isArray(args)) args = [];\n    if (typeof method != 'string') id = '';\n    return data ? {\n      method,\n      args,\n      id,\n      data\n    } : {\n      method,\n      args,\n      id\n    };\n  },\n\n  /* request string builder */\n  request: function (method, args, id, order) {\n    // check the arguments\n    let request = Gamepad.utils.build(method, args, id);\n    method = `method: \\'${request.method}\\'`;\n    args = `args: ${JSON.stringify(request.args)}`;\n    id = `id: \\'${request.id}\\'`; // build the request\n\n    let result = `await worker.setRequest({ ${method}, ${args}, ${id} })\\n`;\n    return order != undefined ? [result, order] : result;\n  },\n\n  /* javascript string builder */\n  js: function (method, args, order, template, statements) {\n    // check the arguments\n    args = Array.isArray(args) ? args : [];\n    statements = Array.isArray(statements) ? statements : []; // code generator function\n\n    return function (block) {\n      let _args = [],\n          _statements = []; // build the args\n\n      for (let arg of args) {\n        let get = typeof arg.get == 'function' ? arg.get : _ => _; // field\n\n        if (arg.field != undefined) {\n          _args.push(get(block.getFieldValue(arg.field))); // input\n\n        } else if (arg.input != undefined) {\n          _args.push(get(Gamepad['INPUTS'][arg.input])); // value\n\n        } else if (arg.value != undefined) {\n          _args.push(get(arg.value));\n        }\n      } // get the code from the input_statement fields\n\n\n      for (let statement of statements) {\n        _statements.push(Blockly.JavaScript.statementToCode(block, statement));\n      } // build the template\n\n\n      switch (template) {\n        case Gamepad['TEMPLATES']['WHILE']:\n          return 'while(' + Gamepad.utils.request(method, _args, block.id) + '){\\n' + _statements[0] + '}';\n\n        case Gamepad['TEMPLATES']['DO_WHILE']:\n          return 'do{' + _statements[0] + '}while{\\n' + Gamepad.utils.request(method, _args, block.id) + '}';\n\n        case Gamepad['TEMPLATES']['IF']:\n          return 'if(' + Gamepad.utils.request(method, _args, block.id) + '){\\n' + _statements[0] + '}';\n\n        case Gamepad['TEMPLATES']['IF_ELSE']:\n          return 'if(' + Gamepad.utils.request(method, _args, block.id) + '){\\n' + _statements[0] + '}else{' + _statements[1] + '}';\n        // simple request\n\n        default:\n          return Gamepad.utils.request(method, _args, block.id, order);\n      }\n    };\n  },\n\n  /* code string builder */\n  code: function (code, times) {\n    // throwing Gamepad[\"ERRORS\"][\"FINISHED\"] will end a level\n    // throwing Gamepad[\"ERRORS\"][\"COMPLETED\"] will end all the levels\n    //  try{\n    //\n    //      try{\n    //          await worker.setRequest({method: Gamepad[\"STATES\"][\"STARTED\"], id: Gamepad[\"STATES\"][\"STARTED\"]});\n    //          ...\n    //          await worker.setRequest({method: Gamepad[\"STATES\"][\"FINISHED\"], id: Gamepad[\"STATES\"][\"FINISHED\"]});\n    //      }catch(error){ \n    //          if(error != Gamepad[\"ERRORS\"][\"FINISHED\"]) throw error; \n    //      }\n    //\n    //      try{\n    //          await worker.setRequest({method: Gamepad[\"STATES\"][\"STARTED\"], id: Gamepad[\"STATES\"][\"STARTED\"]});\n    //          ...\n    //          await worker.setRequest({method: Gamepad[\"STATES\"][\"FINISHED\"], id: Gamepad[\"STATES\"][\"FINISHED\"]});\n    //      }catch(error){ \n    //          if(error != Gamepad[\"ERRORS\"][\"FINISHED\"]) throw error; \n    //      }\n    //\n    //      await worker.setRequest({method: Gamepad[\"STATES\"][\"COMPLETED\"], id: Gamepad[\"STATES\"][\"COMPLETED\"]});\n    //\n    //  }catch(error){\n    //      if(error != Gamepad[\"ERRORS\"][\"COMPLETED\"]) throw error;\n    //  }\n    code = ('try {\\n' + Gamepad.utils.request(Gamepad['STATES']['STARTED'], [], Gamepad['STATES']['STARTED']) + code + Gamepad.utils.request(Gamepad['STATES']['FINISHED'], [], Gamepad['STATES']['FINISHED']) + '} catch(error) { if(error != Gamepad[\"ERRORS\"][\"FINISHED\"]) throw error; }\\n').repeat(times);\n    return 'async function f() {\\n' + '   try{\\n' + code + ( // send the COMPLETED request only if there are more levels\n    times > 1 ? Gamepad.utils.request(Gamepad['STATES']['COMPLETED'], [], Gamepad[\"STATES\"][\"COMPLETED\"]) : '') + '       worker.close();\\n' + '   }catch(error){ if(error != Gamepad[\"ERRORS\"][\"COMPLETED\"]) { throw error; } }\\n' + '   }\\n' + 'f();';\n  },\n\n  /* promise wrapper */\n  promiseWrapper: function () {\n    let resolve,\n        promise = new Promise(res => {\n      resolve = res;\n    });\n    var isPending = true;\n    var isFulfilled = false; // if the promise is fulfilled\n\n    promise.isFulfilled = function () {\n      return isFulfilled;\n    }; // if the promise is pending\n\n\n    promise.isPending = function () {\n      return isPending;\n    }; // resolve the promise\n\n\n    promise.resolve = function (value) {\n      isPending = false;\n      isFulfilled = true;\n      resolve(value);\n    };\n\n    return promise;\n  },\n\n  /* error handler */\n  errorHandler: function (error) {\n    if (error !== Gamepad['ERRORS']['CLOSED']) throw error;\n  }\n};\n/* Gamepad settings loader */\n\nGamepad.setting = function () {\n  // add clear method to the trashcan\n  Blockly.Trashcan.prototype.clear = function () {\n    this.contents_ = new Array();\n  }; // set scrollbar thickness\n\n\n  Blockly.Scrollbar.scrollbarThickness = 12; // custom code generators for procedures\n\n  Blockly.JavaScript.procedures_defreturn = function (a) {\n    var b = Blockly.JavaScript.variableDB_.getName(a.getFieldValue(\"NAME\"), Blockly.Procedures.NAME_TYPE),\n        c = Blockly.JavaScript.statementToCode(a, \"STACK\");\n\n    if (Blockly.JavaScript.STATEMENT_PREFIX) {\n      var d = a.id.replace(/\\$/g, \"$$$$\");\n      c = Blockly.JavaScript.prefixLines(Blockly.JavaScript.STATEMENT_PREFIX.replace(/%1/g, \"'\" + d + \"'\"), Blockly.JavaScript.INDENT) + c;\n    }\n\n    Blockly.JavaScript.INFINITE_LOOP_TRAP && (c = Blockly.JavaScript.INFINITE_LOOP_TRAP.replace(/%1/g, \"'\" + a.id + \"'\") + c);\n    (d = Blockly.JavaScript.valueToCode(a, \"RETURN\", Blockly.JavaScript.ORDER_NONE) || \"\") && (d = Blockly.JavaScript.INDENT + \"return \" + d + \";\\n\");\n\n    for (var e = [], f = 0; f < a.arguments_.length; f++) e[f] = Blockly.JavaScript.variableDB_.getName(a.arguments_[f], Blockly.Variables.NAME_TYPE);\n\n    c = \"async function \" + b + \"(\" + e.join(\", \") + \") {\\n\" + c + d + \"\\n\" + \"}\";\n    c = Blockly.JavaScript.scrub_(a, c);\n    Blockly.JavaScript.definitions_[\"%\" + b] = c;\n    return null;\n  };\n\n  Blockly.JavaScript.procedures_defnoreturn = Blockly.JavaScript.procedures_defreturn;\n\n  Blockly.JavaScript.procedures_callreturn = function (a) {\n    for (var b = Blockly.JavaScript.variableDB_.getName(a.getFieldValue(\"NAME\"), Blockly.Procedures.NAME_TYPE), c = [], d = 0; d < a.arguments_.length; d++) c[d] = Blockly.JavaScript.valueToCode(a, \"ARG\" + d, Blockly.JavaScript.ORDER_COMMA) || \"null\";\n\n    return [\"await \" + b + \"(\" + c.join(\", \") + \")\", Blockly.JavaScript.ORDER_FUNCTION_CALL];\n  };\n\n  Blockly.JavaScript.procedures_callnoreturn = function (a) {\n    for (var b = Blockly.JavaScript.variableDB_.getName(a.getFieldValue(\"NAME\"), Blockly.Procedures.NAME_TYPE), c = [], d = 0; d < a.arguments_.length; d++) c[d] = Blockly.JavaScript.valueToCode(a, \"ARG\" + d, Blockly.JavaScript.ORDER_COMMA) || \"null\";\n\n    return \"await \" + b + \"(\" + c.join(\", \") + \");\\n\";\n  };\n\n  Blockly.JavaScript[Gamepad['BLOCKS']['START']] = function () {\n    return '';\n  }; // set reserved words\n\n\n  Blockly.JavaScript.addReservedWords('Blockly,CONTEXT,worker,code,reject,resolve,f'); // define the start block\n\n  Blockly.defineBlocksWithJsonArray([{\n    \"type\": Gamepad['BLOCKS']['START'],\n    \"message0\": \"Start\",\n    \"deletable_\": false,\n    \"lastDummyAlign0\": \"CENTRE\",\n    \"nextStatement\": null,\n    \"style\": \"hat_blocks\"\n  }]);\n};\n/* Gamepad init function */\n\n\nGamepad.init = function (options) {\n  if (!Blockly) throw new Error('Blockly library not included');\n  if (!Blockly.hasOwnProperty('JavaScript')) throw new Error('JavaScript generator library not included'); // options check\n\n  if (options === undefined) throw new Error('options must not be undefined'); // load the inputs\n\n  if (options.hasOwnProperty('inputs')) this['INPUTS'] = options.inputs; // load the toolbox\n\n  if (options.hasOwnProperty('toolbox')) this['TOOLBOX'] = Gamepad.utils.xml2json(options.toolbox, \"\"); // load the context\n\n  if (options.hasOwnProperty('context')) this['CONTEXT'] = options.context; // load the blocks\n\n  if (options.hasOwnProperty('blocks')) Gamepad.utils.blocks(options.blocks, \"\"); // wrap standar blocks\n\n  if (options.hasOwnProperty('wrap')) Gamepad.utils.wrap(options.wrap, \"\");\n};\n/* Gamepad BlocklyManager */\n// this class manage the workspace and the code generation\n\n\nGamepad.BlocklyManager = class {\n  constructor(options) {\n    options = options || {}; // if someone is changing the workspace\n\n    this.isCoding = false; // if use the strat block\n\n    this.start = options.start === true; // set custom highlight\n\n    this.customHighlight = options.customHighlight === true; // set the workspace, default is Blockly.getMainWorkspace()\n\n    this.workspace = options.workspace || Blockly.getMainWorkspace();\n    this.workspace.addChangeListener(event => {\n      if (event.type == Blockly.Events.BLOCK_MOVE) {\n        // update codinge state and remove block highlight\n        if (!this.isCoding) this.removeHighlight();\n        this.isCoding = true;\n      }\n    });\n    this.reset();\n  } // get the code\n\n\n  code(times) {\n    // update coding state\n    this.isCoding = false; // clear the workspace\n\n    if (this.start) this.clear(); // get the code\n\n    let code = Blockly.JavaScript.workspaceToCode(this.workspace);\n    code = Gamepad.utils.code(code, times);\n    return code;\n  } // clear the workspace\n\n\n  clear() {\n    let blocks = this.workspace.getTopBlocks(); // remove all the blocks expect the start block and the functions\n\n    for (let block of blocks) {\n      if (!block.type.includes('procedures_def') && (!this.start || block.type != Gamepad['BLOCKS']['START'])) block.dispose(false);\n    }\n  } // reset the workspace\n\n\n  reset() {\n    this.workspace.clear();\n    setTimeout(() => {\n      // clear the trashcan\n      if (this.workspace.trashcan) this.workspace.trashcan.clear();\n    }); // if start is enabled the block is generated\n\n    if (this.start) {\n      this.parentBlock = this.workspace.newBlock(Gamepad['BLOCKS']['START'], Gamepad['STATES']['STARTED']);\n      this.parentBlock.setDeletable(false);\n      this.parentBlock.startHat_ = true;\n      this.parentBlock.initSvg();\n      this.parentBlock.render();\n      this.parentBlock.setMovable(false);\n      this.parentBlock.moveBy(20, 20);\n    }\n\n    this.workspace.scrollX = 15;\n    this.workspace.scrollY = 15; // avoid ctrl+z to restore the old workspace\n\n    this.workspace.undoStack_ = [];\n  } // update the toolbox\n\n\n  setToolbox(options) {\n    if (!options) return; // get the toolbox object\n\n    let toolbox = JSON.parse(Gamepad['TOOLBOX']); // show some blocks\n\n    if ('blocks' in options) {\n      if (!Array.isArray(options.blocks)) throw new Error('options.blocks must be an array.'); // filter the json\n\n      Gamepad.utils.filter(toolbox.XML, options);\n      this.workspace.updateToolbox(Gamepad.utils.json2xml(toolbox)); // show all blocks\n    } else if ('all' in options) {\n      this.workspace.updateToolbox(Gamepad.utils.json2xml(toolbox));\n    }\n  } // highlight a block\n\n\n  setHighlight(id) {\n    if (this.customHighlight) {\n      this.removeHighlight();\n\n      try {\n        document.querySelector(\"[data-id='\" + id + \"']\").classList.add('blocklySelected');\n      } catch (error) {}\n    } else {\n      this.workspace.highlightBlock(id);\n    }\n  } // remove the highlight from all the blocks\n\n\n  removeHighlight() {\n    if (this.customHighlight) {\n      let blocks = document.getElementsByClassName(\"blocklySelected\");\n\n      for (let i = blocks.length; i > 0; i--) blocks[i - 1].classList.remove('blocklySelected');\n    } else {\n      this.workspace.highlightBlock();\n    }\n  } // get the blocks number { total: 10, move_up: 2, ...}\n\n\n  getBlocksNumber() {\n    let blocks = this.workspace.getAllBlocks(),\n        result = {\n      total: 0\n    };\n\n    for (let block of blocks) {\n      if (result[block.type] == undefined) result[block.type] = 0;\n      result[block.type]++;\n      result.total++;\n    }\n\n    return result;\n  } // save the workspace in the local storage\n\n\n  save(name) {\n    if (typeof Storage !== \"undefined\") {\n      let xml = Blockly.Xml.workspaceToDom(this.workspace);\n      localStorage.setItem(name, Blockly.Xml.domToText(xml));\n    }\n  } // restore the workspace from the local storage\n\n\n  restore(name) {\n    if (typeof Storage !== \"undefined\") {\n      if (localStorage.getItem(name) != null) {\n        this.workspace.clear();\n\n        try {\n          let xml = Blockly.Xml.textToDom(localStorage.getItem(name));\n          Blockly.Xml.domToWorkspace(xml, this.workspace);\n        } catch (error) {\n          this.reset();\n        }\n      }\n\n      if (this.workspace.trashcan) this.workspace.trashcan.clear();\n\n      if (this.start) {\n        let blocks = this.workspace.getTopBlocks();\n\n        for (let block of blocks) {\n          if (block.type == Gamepad['BLOCKS']['START']) return;\n        }\n\n        this.reset();\n      }\n    }\n  } // resize the workspace\n\n\n  resize() {\n    Blockly.svgResize(this.workspace);\n  }\n\n};\n/* Gamepad History */\n// this class manage a simple history of events\n\nGamepad.History = class {\n  constructor() {\n    this.reset();\n  } // get the length\n\n\n  get length() {\n    return this.history.length;\n  } // add an event\n\n\n  add(event, update) {\n    // remove the events after the current\n    this.history.splice(this.index + 1); // push the event\n\n    this.history.push(event); // update the index\n\n    if (update) this.index = this.length - 1;\n  } // update the current element and return it\n\n\n  get next() {\n    if (this.index < this.length - 1) return this.history[++this.index];\n  } // update the current element and return it\n  // if the current is the first one it becomes undefined\n\n\n  get prior() {\n    if (this.index > -1) return this.history[--this.index];\n  } // get the current event\n\n\n  get current() {\n    if (this.index > -1) return this.history[this.index];\n  } // reset\n\n\n  reset() {\n    this.index = -1;\n    this.history = [];\n  }\n\n};\n/* Gamepad Queue */\n// this class manage an asynchronous queue\n\nGamepad.Queue = class {\n  constructor() {\n    // requests\n    this.requests = []; // if the queue is closed\n\n    this.closed = false; // set the listener\n\n    this.setListener();\n  } // set the listener, once a request is setted the listener is resolved\n\n\n  setListener() {\n    // set the listener\n    this.listener = new Promise((resolve, reject) => {\n      // once a request has been setted this method is called and the listener will manage the get function\n      this.setted = options => {\n        // if there's no options a request has been setted and can be returned by the get method\n        if (!options) return resolve(); // if the queue has been closed the get method will return undefined\n\n        if (options.close) return resolve(true); // if the queue has been resetted throw the closed error\n\n        if (options.reset) return reject(Gamepad['ERRORS']['CLOSED']);\n        resolve();\n      };\n    }); // wrap it to avoid the console.error if it'll be rejected\n\n    this.listener.then(() => {}, () => {});\n  } // reset the queue\n\n\n  reset() {\n    this.requests = [];\n    this.closed = false; // resolve the listener with the reset event\n\n    this.setted({\n      reset: true\n    }); // set the listener\n\n    this.setListener();\n  } // close the queue, get function will return undefined\n\n\n  close() {\n    this.closed = true; // resolve the listener with the close event\n\n    this.setted({\n      close: true\n    });\n  } // open the queue, get function will work normally\n\n\n  open() {\n    this.closed = false;\n  } // get the current request\n  //\n  // if there's no request the set event is awaited\n  //\n  // if there are more calls to this method when the request is not setted \n  // all the callers will receive the same result\n\n\n  get() {\n    // if the queue is closed return undefined\n    if (this.closed) return Promise.resolve(); // set the result and return it\n\n    return this.listener.then(closed => {\n      // if the queue is closed return undefined\n      if (closed) {\n        this.setListener();\n        return;\n      } // resolve the request\n\n\n      let request = this.requests.shift(); // set the listener\n\n      this.setListener(); // if there's at least one request resolve the listener\n\n      if (this.requests.length != 0) this.setted();\n      return request;\n    });\n  } // set the request\n\n\n  set(request) {\n    this.requests.push(request); // if there's al least one request resolve the listener\n\n    this.setted();\n  }\n\n};\n/* Gamepad Asynchronizer */\n// this class generate .async instances of a given target\n\nGamepad.Asynchronizer = class {\n  constructor(sync, onRun, onReset) {\n    this.sync = sync || {};\n    this.async = {};\n\n    this.onRun = onRun || function () {};\n\n    this.onReset = onReset || function () {}; // set the state\n\n\n    this.state = Gamepad.utils.promiseWrapper();\n    this.state.resolve(); // the proxy handler\n\n    this.handler = {\n      // set the getter\n      get: function (obj, prop) {\n        // if has been resetted\n        if (Object.getOwnPropertySymbols(obj).includes(Gamepad['SYMBOL'])) // throw Gamepad['ERRORS']['CLOSED']\n          throw Gamepad['ERRORS']['CLOSED'];else // normal getter\n          return obj[prop];\n      }\n    };\n  } // kill the .async instance\n\n\n  reset() {\n    // if the asynchronizer is resetting\n    if (this.state.isPending()) return; // set the state\n\n    this.state = Gamepad.utils.promiseWrapper(); // set the symbol to check if the async has been resetted\n\n    this.async[Gamepad['SYMBOL']] = true; // call the onReset function\n\n    return this.onReset.apply(this.sync, [...arguments]);\n  } // generate the .async instance\n\n\n  run() {\n    // if the asynchronizer is running\n    if (this.state.isFulfilled()) return; // set the .async copying the properties\n\n    this.async = new Proxy(this.sync && this.sync.prototype ? new this.sync() : Object.defineProperties(Object.assign({}, this.sync), Object.getOwnPropertyDescriptors(this.sync)), this.handler); // call the onRun\n\n    let result = this.onRun.apply(this.async, [...arguments]); // if the result is a Promise\n\n    if (result instanceof Promise) {\n      return result.then(result => {\n        // resolve the state\n        this.state.resolve(); // return the result\n\n        return result;\n      });\n    } else {\n      // resolve the listener\n      this.state.resolve(); // return the result\n\n      return result;\n    }\n  }\n\n};\n/* Gamepad Worker */\n// The worker manage the request from the blocks\n\nGamepad.Worker = function () {\n  const asynchronizer = new Gamepad.Asynchronizer({\n    // history for the old requests\n    history: new Gamepad.History(),\n    // queue for forward/backward requests\n    queue: new Gamepad.Queue(),\n    // queue for blocks's requests\n    requests: new Gamepad.Queue(),\n    // debugger\n    debugger: {\n      // id of the block used as breakpoint\n      id: null,\n      // promise resolved on breakpoint reached\n      promise: Gamepad.utils.promiseWrapper()\n    },\n    // if the worker is running\n    isRunning: false,\n    // running direction\n    back: false,\n    // create a forward/backward request\n    go: function (back) {\n      return new Promise(resolve => {\n        this.queue.set({\n          back: back === true,\n          resolve\n        });\n      });\n    },\n    // free the queue\n    freeQueue: function () {\n      // get the requests\n      this.queue.close();\n      const requests = this.queue.requests;\n      this.queue.reset(); // resolve each request\n\n      requests.forEach(request => request && request.resolve && request.resolve(false));\n    },\n    // start the worker\n    start: function (back) {\n      this.back = back === true; // if it is running\n\n      if (this.isRunning) return; // update running state\n\n      this.isRunning = true; // free the queue getter (.get())\n\n      this.queue.close();\n      this.queue.open();\n    },\n    // stop the worker\n    stop: function () {\n      this.isRunning = false;\n      this.removeBreakpoint();\n    },\n    // set a request from the blocks\n    setRequest: function (request) {\n      return new Promise((resolve, reject) => {\n        this.requests.set({\n          request,\n          resolve,\n          reject\n        });\n      });\n    },\n    // close the worker, requests are not passed anymore\n    close: function () {\n      this.requests.close();\n    },\n    // open the worker\n    open: function () {\n      this.requests.open();\n    },\n    // set as breakpoint the request with the passed id\n    setBreakpoint: function (id) {\n      if (id === undefined) return;\n      if (id === null && this.debugger.id === null) return; // end old debugger\n\n      if (this.debugger.promise.isPending()) this.debugger.promise.resolve(false); // set the debugger\n\n      this.debugger.id = id;\n      this.debugger.promise = Gamepad.utils.promiseWrapper(); // don't return the wrapped promise\n\n      return this.debugger.promise.then(result => result);\n    },\n    // remove the current breakpoint\n    removeBreakpoint: function () {\n      this.setBreakpoint(null);\n    }\n  }, function () {\n    // start the flow or requests\n    const start = async () => {\n      try {\n        while (true) {\n          // if is running load a forward request\n          // else get from the queue\n          let request = this.isRunning ? {\n            back: this.back\n          } : (await this.queue.get()) || {\n            p: 'p',\n            back: this.back\n          }; // backward or forward\n\n          request.back ? await backward() : await forward(); // resolve the forward/backward request\n\n          if (request.resolve) request.resolve(true);\n        }\n      } catch (error) {\n        // don't throw the error if the worker has been resetted\n        Gamepad.utils.errorHandler(error);\n      }\n    }; // backward manager\n\n\n    const backward = async () => {\n      // get the request from the history\n      let request = this.history.current; // load prior request\n\n      this.history.prior; // the first history item is undefined\n\n      if (request !== undefined) {\n        await this.manage(request, true, true); // debug check\n\n        debug(request.id);\n      } else {\n        this.stop();\n      }\n    }; // forward manager\n\n\n    const forward = async () => {\n      let request, result; // if there's a request in the history\n\n      if ((request = this.history.next) !== undefined) {\n        await this.manage(request, false, true); // debug check\n\n        debug(request.id);\n        return;\n      } // get the request from the queue\n\n\n      request = await this.requests.get(); // if the worker has been closed the request will be undefined\n\n      if (request === undefined) {\n        this.stop();\n        return;\n      }\n\n      if (this.history.current) {\n        // it's possible that a block pass the 'FINISHED' state\n        // when it's passed the upcoming requests need to be killed until the next 'STARTED' state\n        if (this.history.current.method == Gamepad['STATES']['FINISHED']) {\n          if (request.request.method != Gamepad['STATES']['STARTED'] && request.request.method != Gamepad['STATES']['COMPLETED']) {\n            // throwing Gamepad['STATES']['FINISHED'] will kill all the requests until the next 'STARTED' state \n            request.reject(Gamepad['ERRORS']['FINISHED']);\n            return;\n          }\n        } // it's possible that a block pass the 'COMPLETED' state\n        // when it's passed all the requests need to be killed\n\n\n        if (this.history.current.method == Gamepad['STATES']['COMPLETED']) {\n          // throwing Gamepad['STATES']['COMPLETED'] will kill all the requests\n          request.reject(Gamepad['ERRORS']['COMPLETED']);\n          this.stop();\n          return;\n        }\n      } // manage the request\n\n\n      result = await this.manage(request.request, false, false);\n      if (result === undefined) result = {}; // add the request to the history\n\n      this.history.add(request.request, true); // debug check\n\n      debug(request.request.id);\n\n      if (result.finished) {\n        // if result.finished reject the 'FINISHED' error\n        // all the upcoming requests are killed until the next 'STARTED' state\n        // the current request is now the 'FINISHED' one but it is not passed to the game\n        this.history.add(Gamepad.utils.build(Gamepad['STATES']['FINISHED'], [], Gamepad['STATES']['FINISHED'], {\n          generated: true\n        }), true); // load the request\n\n        this.history.next; // debug check because that request is loaded but it is not passed to the game\n\n        debug(Gamepad['STATES']['FINISHED']); // throw the error\n\n        request.reject(Gamepad['ERRORS']['FINISHED']);\n      } else if (result.completed) {\n        // if result.finished reject the 'COMPLETED' error\n        // all the requests are killed\n        // the current request is now the 'COMPLETED' one but it is not passed to the game\n        this.history.add(Gamepad.utils.build(Gamepad['STATES']['COMPLETED'], [], Gamepad['STATES']['COMPLETED'], {\n          generated: true\n        }), true); // load the request\n\n        this.history.next; // debug check because that request is loaded but it is not passed to the game\n\n        debug(Gamepad['STATES']['COMPLETED']); // throw the error\n\n        request.reject(Gamepad['ERRORS']['COMPLETED']); // close the worker\n\n        this.close();\n      } else {\n        request.resolve(result.return);\n      }\n    }; // debug check\n\n\n    const debug = id => {\n      if (this.debugger.id !== null && this.debugger.id == id) {\n        this.debugger.promise.resolve(true);\n        this.freeQueue();\n        this.stop();\n      }\n    };\n\n    start();\n  }, function () {\n    // free the queue\n    this.freeQueue(); // reset\n\n    this.queue.reset();\n    this.requests.reset();\n    this.history.reset(); // remove the breakpoint\n\n    this.removeBreakpoint();\n  }); // methods\n\n  Object.assign(this, {\n    // reset\n    reset: function () {\n      asynchronizer.reset();\n      asynchronizer.run();\n    },\n    // request manager\n    onRequest: function (thisArg, method) {\n      asynchronizer.sync.manage = function (request, back, old) {\n        return method.apply(thisArg, [request, back, old]);\n      };\n    },\n    // return the current async\n    // the .async will be used by the code generators\n    getInstance: function () {\n      return asynchronizer.async;\n    }\n  }); // link the async methods\n\n  for (const method of ['go', 'setRequest', 'start', 'stop', 'close', 'freeQueue', 'setBreakpoint', 'removeBreakpoint']) {\n    this[method] = function () {\n      let ac = asynchronizer.async;\n\n      try {\n        return ac[method].apply(ac, [...arguments]);\n      } catch (error) {\n        Gamepad.utils.errorHandler(error);\n      }\n    };\n  } // link the async properties\n\n\n  for (const property of ['isRunning', 'back']) {\n    Object.defineProperty(this, property, {\n      get: function () {\n        try {\n          return asynchronizer.async[property];\n        } catch (error) {}\n      }\n    });\n  }\n\n  this.reset();\n};\n/* eval function */\n\n\nGamepad.evalContext = function (code, worker) {\n  try {\n    let CONTEXT = Gamepad['CONTEXT'];\n    eval(code);\n  } catch (err) {\n    console.error('There\\'s an error in the code: \\n', code);\n    console.error(err);\n  }\n};\n/* Gamepad observer */\n// the observer instances are used to manage the magicJson options\n\n\nGamepad.observer = {\n  // insert event\n  INSERT: 'insert',\n  // update event\n  UPDATE: 'update',\n  // delete event\n  DELETE: 'delete',\n  // pop event\n  POP: 'pop',\n  // push event\n  PUSH: 'push',\n  // shift event\n  SHIFT: 'shift',\n  // unshift event\n  UNSHIFT: 'unshift',\n  // reverse event\n  REVERSE: 'reverse',\n  // non observable object\n  nonObservables: {\n    Date: true,\n    Blob: true,\n    Number: true,\n    String: true,\n    Boolean: true,\n    Error: true,\n    SyntaxError: true,\n    TypeError: true,\n    URIError: true,\n    Function: true,\n    Promise: true,\n    RegExp: true\n  },\n  // observable definition\n  observableDefinition: {\n    // reverse\n    revoke: {\n      value: function () {\n        this[Gamepad['SYMBOL']].revoke();\n      }\n    },\n    // observe changes\n    observe: {\n      value: function (observer, options) {\n        let systemObserver = this[Gamepad['SYMBOL']],\n            observers = systemObserver.observers;\n\n        if (typeof observer !== 'function') {\n          throw new Error('observer parameter MUST be a function');\n        }\n\n        if (!observers.has(observer)) {\n          observers.set(observer, Object.assign({}, options));\n        }\n      }\n    },\n    // unobserve\n    unobserve: {\n      value: function () {\n        let systemObserver = this[Gamepad['SYMBOL']],\n            observers = systemObserver.observers,\n            l;\n\n        if (observers.size) {\n          l = arguments.length;\n\n          if (l) {\n            while (l--) {\n              observers.delete(arguments[l]);\n            }\n          } else {\n            observers.clear();\n          }\n        }\n      }\n    }\n  },\n  // load the array\n  prepareArray: function (source, observer) {\n    let l = source.length,\n        item;\n    let target = new Array(source.length); // bind the observer\n\n    target[Gamepad['SYMBOL']] = observer; // prepare the children\n\n    while (l--) {\n      item = source[l];\n\n      if (item && typeof item === 'object' && !Gamepad.observer.nonObservables.hasOwnProperty(item.constructor.name)) {\n        target[l] = Array.isArray(item) ? new Gamepad.ArrayObserver({\n          target: item,\n          ownKey: l,\n          parent: observer\n        }).proxy : new Gamepad.ObjectObserver({\n          target: item,\n          ownKey: l,\n          parent: observer\n        }).proxy;\n      } else {\n        target[l] = item;\n      }\n    }\n\n    return target;\n  },\n  // load the object\n  prepareObject: function (source, observer) {\n    let keys = Object.keys(source),\n        l = keys.length,\n        key,\n        item;\n    let target = {\n      // bind the observer\n      [Gamepad['SYMBOL']]: observer\n    }; // prepare the children\n\n    while (l--) {\n      key = keys[l];\n      item = source[key];\n\n      if (item && typeof item === 'object' && !Gamepad.observer.nonObservables.hasOwnProperty(item.constructor.name)) {\n        target[key] = Array.isArray(item) ? new Gamepad.ArrayObserver({\n          target: item,\n          ownKey: key,\n          parent: observer\n        }).proxy : new Gamepad.ObjectObserver({\n          target: item,\n          ownKey: key,\n          parent: observer\n        }).proxy;\n      } else {\n        target[key] = item;\n      }\n    }\n\n    return target;\n  },\n  // call the observers\n  callObservers: function (observers, changes) {\n    for (let target of observers.keys()) {\n      try {\n        let relevantChanges = changes;\n        target(relevantChanges);\n      } catch (e) {\n        console.error('failed to deliver changes to listener ' + target, e);\n      }\n    }\n  },\n  // get ancestor info\n  getAncestorInfo: function (self) {\n    let tmp = [],\n        result,\n        l1 = 0,\n        l2 = 0; // if the object is revoked return undefined\n\n    if (self.isRevoked) {\n      return;\n    } // find the first parent\n\n\n    while (self.parent) {\n      tmp[l1++] = self.ownKey;\n      self = self.parent;\n\n      if (self.isRevoked) {\n        return;\n      }\n    }\n\n    result = new Array(l1);\n\n    while (l1--) result[l2++] = tmp[l1];\n\n    return {\n      observers: self.observers,\n      path: result\n    };\n  },\n  // get the last property \n  // (target, ['a', 'b', 'c']) => { target: target.a.b, key: 'c'}\n  getLastProp: function (target, path) {\n    for (let i = 0; i < path.length - 1; i++) target = target[path[i]];\n\n    return {\n      key: path[path.length - 1],\n      target\n    };\n  },\n  // load single change\n  loadChange: function (observer, change) {\n    let {\n      target,\n      key\n    } = Gamepad.observer.getLastProp(observer, change.path); // objects and arrays need different changes with the INSERT and DELETE events\n\n    if (Array.isArray(target)) {\n      if (change.type == Gamepad.observer.INSERT) {\n        // if the key isn't a number the if is false and it will set the value correctly\n        if (target.length > key) target.splice(key, 0, change.value);else target[key] = change.value;\n      }\n\n      if (change.type == Gamepad.observer.DELETE) target.splice(key, 1);\n    } else {\n      if (change.type == Gamepad.observer.INSERT) target[key] = change.value;\n      if (change.type == Gamepad.observer.DELETE) delete target[key];\n    } // array only changes\n\n\n    if (change.type == Gamepad.observer.PUSH) target[key].push.apply(target, change.value);\n    if (change.type == Gamepad.observer.POP) target[key].pop();\n    if (change.type == Gamepad.observer.UNSHIFT) target[key].unshift.apply(target, change.value);\n    if (change.type == Gamepad.observer.SHIFT) target[key].shift();\n    if (change.type == Gamepad.observer.REVERSE) target[key].reverse(); // common changes\n\n    if (change.type == Gamepad.observer.UPDATE) target[key] = change.value;\n  },\n  // unload single change\n  unloadChange: function (observer, change) {\n    let {\n      target,\n      key\n    } = Gamepad.observer.getLastProp(observer, change.path); // objects and arrays need different changes with the INSERT and DELETE events\n\n    if (Array.isArray(target)) {\n      if (change.type == Gamepad.observer.INSERT) {\n        // if the key isn't a number the if is false and it will set the value correctly\n        if (target.length > key) target.splice(key, 1);else delete target[key];\n      }\n\n      if (change.type == Gamepad.observer.DELETE) target.splice(key, 0, change.oldValue);\n    } else {\n      if (change.type == Gamepad.observer.INSERT) delete target[key];\n      if (change.type == Gamepad.observer.DELETE) target[key] = change.oldValue;\n    } // array only changes\n\n\n    if (change.type == Gamepad.observer.PUSH) {\n      for (let i = 0; i < change.value.length; i++) target[key].pop();\n    }\n\n    if (change.type == Gamepad.observer.POP) target[key].push(change.oldValue);\n\n    if (change.type == Gamepad.observer.UNSHIFT) {\n      for (let i = 0; i < change.value.length; i++) target[key].shift();\n    }\n\n    if (change.type == Gamepad.observer.SHIFT) target[key].unshift(change.oldValue);\n    if (change.type == Gamepad.observer.REVERSE) target[key].reverse(); // common changes\n\n    if (change.type == Gamepad.observer.UPDATE) target[key] = change.oldValue;\n  },\n  // observe a json\n  observeJson: function (target) {\n    if (target && typeof target === 'object' && !Gamepad.observer.nonObservables.hasOwnProperty(target.constructor.name) && !('observe' in target) && !('unobserve' in target) && !('revoke' in target)) {\n      let observed = Array.isArray(target) ? new Gamepad.ArrayObserver({\n        target: target,\n        ownKey: null,\n        parent: null\n      }) : new Gamepad.ObjectObserver({\n        target: target,\n        ownKey: null,\n        parent: null\n      });\n      return observed.proxy;\n    } else {\n      if (!target || typeof target !== 'object') {\n        throw new Error('observable MAY ONLY be created from non-null object only');\n      } else if ('observe' in target || 'unobserve' in target || 'revoke' in target) {\n        throw new Error('target object MUST NOT have nor own neither inherited properties from the following list: \"observe\", \"unobserve\", \"revoke\"');\n      } else if (Gamepad.observer.nonObservables.hasOwnProperty(target.constructor.name)) {\n        throw new Error(target + ' found to be one of non-observable object types: ' + Gamepad.observer.nonObservables);\n      }\n    }\n  }\n};\n/* Observer class */\n// the observer class generate a Proxy that wrap a target object\n// It's possible to bind a listener to the changes of the proxy\n\nGamepad.Observer = class {\n  constructor(properties, cloningFunction) {\n    // prepare the source\n    let source = properties.target,\n        targetClone = cloningFunction(source, this); // bind to parents\n\n    if (properties.parent === null) {\n      this.isRevoked = false;\n      Object.defineProperty(this, 'observers', {\n        value: new Map()\n      });\n      Object.defineProperties(targetClone, Gamepad.observer.observableDefinition);\n    } else {\n      this.parent = properties.parent;\n      this.ownKey = properties.ownKey;\n    } // set the proxy\n\n\n    this.revokable = Proxy.revocable(targetClone, this);\n    this.proxy = this.revokable.proxy;\n    this.target = targetClone;\n  } // set trap\n\n\n  set(target, key, value) {\n    // if the proxy is revoked it will work as a normal object\n    if (this.isRevoked) {\n      target[key] = value;\n      return true;\n    }\n\n    let newValue,\n        oldValue = target[key],\n        ad,\n        changes; // prepare the value\n\n    if (value && typeof value === 'object' && !Gamepad.observer.nonObservables.hasOwnProperty(value.constructor.name)) {\n      newValue = Array.isArray(value) ? new Gamepad.ArrayObserver({\n        target: value,\n        ownKey: key,\n        parent: this\n      }).proxy : new Gamepad.ObjectObserver({\n        target: value,\n        ownKey: key,\n        parent: this\n      }).proxy;\n    } else {\n      newValue = value;\n    }\n\n    target[key] = newValue; // revoke the old object\n\n    if (oldValue && typeof oldValue === 'object') {\n      let tmpObserved = oldValue[Gamepad['SYMBOL']];\n\n      if (tmpObserved) {\n        oldValue = tmpObserved.revoke();\n      }\n    } // push changes\n\n\n    ad = Gamepad.observer.getAncestorInfo(this);\n    if (!ad) return;\n\n    if (ad.observers.size) {\n      ad.path.push(key);\n      changes = typeof oldValue === 'undefined' ? [{\n        type: Gamepad.observer.INSERT,\n        path: ad.path,\n        value: newValue,\n        object: this.proxy\n      }] : [{\n        type: Gamepad.observer.UPDATE,\n        path: ad.path,\n        value: newValue,\n        oldValue: oldValue,\n        object: this.proxy\n      }];\n      Gamepad.observer.callObservers(ad.observers, changes);\n    }\n\n    return true;\n  } // delete trap\n\n\n  deleteProperty(target, key) {\n    let oldValue = target[key],\n        ad,\n        changes;\n\n    if (delete target[key]) {\n      // revoke the old object\n      if (oldValue && typeof oldValue === 'object') {\n        let tmpObserved = oldValue[Gamepad['SYMBOL']];\n\n        if (tmpObserved) {\n          oldValue = tmpObserved.revoke();\n        }\n      } // push changes\n\n\n      ad = Gamepad.observer.getAncestorInfo(this);\n      if (!ad) return;\n\n      if (ad.observers.size) {\n        ad.path.push(key);\n        changes = [{\n          type: Gamepad.observer.DELETE,\n          path: ad.path,\n          oldValue: oldValue,\n          object: this.proxy\n        }];\n        Gamepad.observer.callObservers(ad.observers, changes);\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\n/* Array observer class */\n// observer for arrays\n\nGamepad.ArrayObserver = class extends Gamepad.Observer {\n  constructor(properties) {\n    super(properties, Gamepad.observer.prepareArray);\n  } // revoke the observer, now it will work as a normal object\n\n\n  revoke() {\n    // set isRevoked prop\n    this.isRevoked = true;\n    let target = this.target,\n        l = target.length,\n        item; // revoke children\n\n    while (l--) {\n      item = target[l]; // send revoke event to all sons\n\n      if (item && typeof item === 'object') {\n        let tmpObserved = item[Gamepad['SYMBOL']];\n\n        if (tmpObserved) {\n          target[l] = tmpObserved.revoke();\n        }\n      }\n    }\n\n    return target;\n  } // get trap\n\n\n  get(target, key) {\n    // array methods\n    const proxiedArrayMethods = {\n      pop: function proxiedPop(target, observed) {\n        if (target.length == 0) return;\n        let popResult;\n        popResult = target.pop();\n\n        if (popResult && typeof popResult === 'object') {\n          let tmpObserved = popResult[Gamepad['SYMBOL']];\n\n          if (tmpObserved) {\n            popResult = tmpObserved.revoke();\n          }\n        }\n\n        let ad = Gamepad.observer.getAncestorInfo(observed);\n        if (!ad) return;\n\n        if (ad.observers.size) {\n          Gamepad.observer.callObservers(ad.observers, [{\n            type: Gamepad.observer.POP,\n            path: ad.path,\n            oldValue: popResult,\n            object: observed.proxy\n          }]);\n        }\n\n        return popResult;\n      },\n      push: function proxiedPush(target, observed) {\n        let i,\n            l = arguments.length - 2,\n            item,\n            pushContent = new Array(l),\n            pushResult,\n            changes,\n            initialLength,\n            ad = Gamepad.observer.getAncestorInfo(observed);\n        initialLength = target.length;\n\n        for (i = 0; i < l; i++) {\n          item = arguments[i + 2];\n\n          if (item && typeof item === 'object' && !Gamepad.observer.nonObservables.hasOwnProperty(item.constructor.name)) {\n            item = Array.isArray(item) ? new Gamepad.ArrayObserver({\n              target: item,\n              ownKey: initialLength + i,\n              parent: observed\n            }).proxy : new Gamepad.ObjectObserver({\n              target: item,\n              ownKey: initialLength + i,\n              parent: observed\n            }).proxy;\n          }\n\n          pushContent[i] = item;\n        }\n\n        pushResult = Reflect.apply(target.push, target, pushContent);\n        if (!ad) return;\n\n        if (ad.observers.size) {\n          changes = [{\n            type: Gamepad.observer.PUSH,\n            path: ad.path,\n            value: pushContent,\n            object: observed.proxy\n          }];\n          Gamepad.observer.callObservers(ad.observers, changes);\n        }\n\n        return pushResult;\n      },\n      shift: function proxiedShift(target, observed) {\n        if (target.length == 0) return;\n        let shiftResult, i, l, item, ad, changes;\n        shiftResult = target.shift();\n\n        if (shiftResult && typeof shiftResult === 'object') {\n          let tmpObserved = shiftResult[Gamepad['SYMBOL']];\n\n          if (tmpObserved) {\n            shiftResult = tmpObserved.revoke();\n          }\n        }\n\n        for (i = 0, l = target.length; i < l; i++) {\n          item = target[i];\n\n          if (item && typeof item === 'object') {\n            let tmpObserved = item[Gamepad['SYMBOL']];\n\n            if (tmpObserved) {\n              tmpObserved.ownKey = i;\n            }\n          }\n        }\n\n        ad = Gamepad.observer.getAncestorInfo(observed);\n        if (!ad) return;\n\n        if (ad.observers.size) {\n          changes = [{\n            type: Gamepad.observer.SHIFT,\n            path: ad.path,\n            oldValue: shiftResult,\n            object: observed.proxy\n          }];\n          Gamepad.observer.callObservers(ad.observers, changes);\n        }\n\n        return shiftResult;\n      },\n      unshift: function proxiedUnshift(target, observed) {\n        let unshiftContent, unshiftResult, ad, changes;\n        unshiftContent = Array.from(arguments);\n        unshiftContent.splice(0, 2);\n        unshiftContent.forEach((item, index) => {\n          if (item && typeof item === 'object' && !Gamepad.observer.nonObservables.hasOwnProperty(item.constructor.name)) {\n            unshiftContent[index] = Array.isArray(item) ? new Gamepad.ArrayObserver({\n              target: item,\n              ownKey: index,\n              parent: observed\n            }).proxy : new Gamepad.ObjectObserver({\n              target: item,\n              ownKey: index,\n              parent: observed\n            }).proxy;\n          }\n        });\n        unshiftResult = Reflect.apply(target.unshift, target, unshiftContent);\n\n        for (let i = 0, l = target.length, item; i < l; i++) {\n          item = target[i];\n\n          if (item && typeof item === 'object') {\n            let tmpObserved = item[Gamepad['SYMBOL']];\n\n            if (tmpObserved) {\n              tmpObserved.ownKey = i;\n            }\n          }\n        }\n\n        ad = Gamepad.observer.getAncestorInfo(observed);\n        if (!ad) return;\n\n        if (ad.observers.size) {\n          changes = [{\n            type: Gamepad.observer.UNSHIFT,\n            path: ad.path,\n            value: unshiftContent,\n            object: observed.proxy\n          }];\n          Gamepad.observer.callObservers(ad.observers, changes);\n        }\n\n        return unshiftResult;\n      },\n      reverse: function proxiedReverse(target, observed) {\n        let i, l, item, ad, changes;\n        target.reverse();\n\n        for (i = 0, l = target.length; i < l; i++) {\n          item = target[i];\n\n          if (item && typeof item === 'object') {\n            let tmpObserved = item[Gamepad['SYMBOL']];\n\n            if (tmpObserved) {\n              tmpObserved.ownKey = i;\n            }\n          }\n        }\n\n        ad = Gamepad.observer.getAncestorInfo(observed);\n        if (!ad) return;\n\n        if (ad.observers.size) {\n          changes = [{\n            type: Gamepad.observer.REVERSE,\n            path: ad.path,\n            object: observed.proxy\n          }];\n          Gamepad.observer.callObservers(ad.observers, changes);\n        }\n\n        return observed.proxy;\n      },\n      sort: function proxiedSort(target, observed, comparator) {\n        let i,\n            l,\n            item,\n            ad,\n            changes,\n            oldValue = target.slice(0);\n        target.sort(comparator);\n\n        for (i = 0, l = target.length; i < l; i++) {\n          item = target[i];\n\n          if (item && typeof item === 'object') {\n            let tmpObserved = item[Gamepad['SYMBOL']];\n\n            if (tmpObserved) {\n              tmpObserved.ownKey = i;\n            }\n          }\n        }\n\n        ad = Gamepad.observer.getAncestorInfo(observed);\n        if (!ad) return;\n\n        if (ad.observers.size) {\n          changes = [{\n            type: Gamepad.observer.UPDATE,\n            value: target,\n            oldValue,\n            path: ad.path,\n            object: observed.proxy\n          }];\n          Gamepad.observer.callObservers(ad.observers, changes);\n        }\n\n        return observed.proxy;\n      },\n      fill: function proxiedFill(target, observed) {\n        let ad = Gamepad.observer.getAncestorInfo(observed),\n            normArgs,\n            argLen,\n            start,\n            end,\n            changes = [],\n            prev,\n            tarLen = target.length,\n            path;\n        normArgs = Array.from(arguments);\n        normArgs.splice(0, 2);\n        argLen = normArgs.length;\n        start = argLen < 2 ? 0 : normArgs[1] < 0 ? tarLen + normArgs[1] : normArgs[1];\n        end = argLen < 3 ? tarLen : normArgs[2] < 0 ? tarLen + normArgs[2] : normArgs[2];\n        prev = target.slice(0);\n        Reflect.apply(target.fill, target, normArgs);\n\n        for (let i = start, item, tmpTarget; i < end; i++) {\n          item = target[i];\n\n          if (item && typeof item === 'object' && !Gamepad.observer.nonObservables.hasOwnProperty(item.constructor.name)) {\n            target[i] = Array.isArray(item) ? new Gamepad.ArrayObserver({\n              target: item,\n              ownKey: i,\n              parent: observed\n            }).proxy : new Gamepad.ObjectObserver({\n              target: item,\n              ownKey: i,\n              parent: observed\n            }).proxy;\n          }\n\n          if (prev.hasOwnProperty(i)) {\n            tmpTarget = prev[i];\n\n            if (tmpTarget && typeof tmpTarget === 'object') {\n              let tmpObserved = tmpTarget[Gamepad['SYMBOL']];\n\n              if (tmpObserved) {\n                tmpTarget = tmpObserved.revoke();\n              }\n            }\n\n            path = ad.path.slice(0);\n            path.push(i);\n            changes.push({\n              type: Gamepad.observer.UPDATE,\n              path: path,\n              value: target[i],\n              oldValue: tmpTarget,\n              object: observed.proxy\n            });\n          } else {\n            path = ad.path.slice(0);\n            path.push(i);\n            changes.push({\n              type: Gamepad.observer.INSERT,\n              path: path,\n              value: target[i],\n              object: observed.proxy\n            });\n          }\n        }\n\n        if (!ad) return;\n\n        if (ad.observers.size) {\n          Gamepad.observer.callObservers(ad.observers, changes);\n        }\n\n        return observed.proxy;\n      },\n      splice: function proxiedSplice(target, observed) {\n        let ad = Gamepad.observer.getAncestorInfo(observed),\n            spliceContent,\n            spliceResult,\n            changes = [],\n            tmpObserved,\n            startIndex,\n            removed,\n            inserted,\n            splLen,\n            tarLen = target.length;\n        spliceContent = Array.from(arguments);\n        spliceContent.splice(0, 2);\n        splLen = spliceContent.length;\n\n        for (let i = 2, item; i < splLen; i++) {\n          item = spliceContent[i];\n\n          if (item && typeof item === 'object' && !Gamepad.observer.nonObservables.hasOwnProperty(item.constructor.name)) {\n            spliceContent[i] = Array.isArray(item) ? new Gamepad.ArrayObserver({\n              target: item,\n              ownKey: i,\n              parent: observed\n            }).proxy : new Gamepad.ObjectObserver({\n              target: item,\n              ownKey: i,\n              parent: observed\n            }).proxy;\n          }\n        }\n\n        startIndex = splLen === 0 ? 0 : spliceContent[0] < 0 ? tarLen + spliceContent[0] : spliceContent[0];\n        removed = splLen < 2 ? tarLen - startIndex : spliceContent[1];\n        inserted = Math.max(splLen - 2, 0);\n        spliceResult = Reflect.apply(target.splice, target, spliceContent);\n        tarLen = target.length;\n\n        for (let i = 0, item; i < tarLen; i++) {\n          item = target[i];\n\n          if (item && typeof item === 'object') {\n            tmpObserved = item[Gamepad['SYMBOL']];\n\n            if (tmpObserved) {\n              tmpObserved.ownKey = i;\n            }\n          }\n        }\n\n        let i, l, item;\n\n        for (i = 0, l = spliceResult.length; i < l; i++) {\n          item = spliceResult[i];\n\n          if (item && typeof item === 'object') {\n            tmpObserved = item[Gamepad['SYMBOL']];\n\n            if (tmpObserved) {\n              spliceResult[i] = tmpObserved.revoke();\n            }\n          }\n        }\n\n        if (!ad) return;\n\n        if (ad.observers.size) {\n          let index, path;\n\n          for (index = 0; index < removed; index++) {\n            path = ad.path.slice(0);\n            path.push(startIndex + index);\n\n            if (index < inserted) {\n              changes.push({\n                type: Gamepad.observer.UPDATE,\n                path: path,\n                value: target[startIndex + index],\n                oldValue: spliceResult[index],\n                object: observed.proxy\n              });\n            } else {\n              changes.push({\n                type: Gamepad.observer.DELETE,\n                path: path,\n                oldValue: spliceResult[index],\n                object: observed.proxy\n              });\n            }\n          }\n\n          for (; index < inserted; index++) {\n            path = ad.path.slice(0);\n            path.push(startIndex + index);\n            changes.push({\n              type: Gamepad.observer.INSERT,\n              path: path,\n              value: target[startIndex + index],\n              object: observed.proxy\n            });\n          }\n\n          Gamepad.observer.callObservers(ad.observers, changes);\n        }\n\n        return spliceResult;\n      }\n    };\n\n    if (proxiedArrayMethods.hasOwnProperty(key)) {\n      return proxiedArrayMethods[key].bind(undefined, target, this);\n    } else {\n      return target[key];\n    }\n  }\n\n};\n/* Object observer class */\n// observer for objects\n\nGamepad.ObjectObserver = class extends Gamepad.Observer {\n  constructor(properties) {\n    super(properties, Gamepad.observer.prepareObject);\n  } // revoke the observer, now it will work as a normal object\n\n\n  revoke() {\n    // set isRevoked prop\n    this.isRevoked = true;\n    let target = this.target,\n        keys = Object.keys(target),\n        l = keys.length,\n        key,\n        item; // revoke each children\n\n    while (l--) {\n      key = keys[l];\n      item = target[key];\n\n      if (item && typeof item === 'object') {\n        let tmpObserved = item[Gamepad['SYMBOL']];\n\n        if (tmpObserved) {\n          target[key] = tmpObserved.revoke();\n        }\n      }\n    }\n\n    return target;\n  }\n\n};\n/* Gamepad Store */\n// this class manage the changes of a single observer\n\nGamepad.Store = class {\n  constructor(json) {\n    // the changes observer\n    this.observer = Gamepad.observer.observeJson(json); // history of changes\n\n    this.history = []; // history index\n\n    this.index = -1; // current changes\n\n    this.changes = []; // observe the json\n\n    this.observer.observe(changes => {\n      changes.forEach(change => {\n        //  update this part.\n        // the values are not saved directly because they can change\n        if ('value' in change && change.value != undefined) change.value = JSON.parse(JSON.stringify(change.value));\n        if ('oldValue' in change && change.oldValue != undefined) change.oldValue = JSON.parse(JSON.stringify(change.oldValue));\n        this.changes.push(change);\n      });\n    });\n  } // commit changes\n\n\n  commit() {\n    // update the history\n    this.history.splice(this.index + 1);\n    this.history.push(this.changes);\n    this.index = this.history.length - 1; // remove changes\n\n    this.changes = [];\n  } // unload all changes that have not been committed\n\n\n  restore() {\n    let changes = this.changes.slice(0);\n\n    while (changes.length > 0) Gamepad.observer.unloadChange(this.observer, changes.pop());\n\n    this.changes = [];\n  } // load all changes\n\n\n  loadChanges() {\n    // remove useless changes\n    this.restore(); // if there are change to load\n\n    if (this.index < this.history.length - 1) {\n      // change store\n      this.index++;\n      let changes = this.history[this.index],\n          i = -1; // load all changes\n\n      while (++i < changes.length) Gamepad.observer.loadChange(this.observer, changes[i]); // remove the changes that this process has created\n\n\n      this.changes = [];\n    }\n  } // unload all changes\n\n\n  unloadChanges() {\n    // remove useless changes\n    this.restore(); // if there are changes to unload\n\n    if (this.index > -1) {\n      let changes = this.history[this.index],\n          i = changes.length; // unload all changes\n\n      while (--i >= 0) Gamepad.observer.unloadChange(this.observer, changes[i]); // change store\n\n\n      this.index--; // remove the changes that this process has created\n\n      this.changes = [];\n    }\n  }\n\n};\n/* Gamepad JsonManager */\n// this class manage multiple stores\n\nGamepad.JsonManager = class {\n  constructor(json) {\n    this.init(json || {});\n  } // reset the stores\n\n\n  reset() {\n    this.init();\n  } // init a new json\n\n\n  init(json) {\n    // update the old json\n    if (json !== undefined) this.json = json; // stores\n\n    this.stores = []; // stores index\n\n    this.index = 0; // load the stores\n\n    if (Array.isArray(this.json)) {\n      for (let value of this.json) this.stores.push(new Gamepad.Store(value));\n    } else {\n      this.stores.push(new Gamepad.Store(this.json));\n    } // the stores should not be changed here\n\n\n    Object.freeze(this.stores);\n  } // get the current store\n\n\n  get store() {\n    return this.stores[this.index];\n  } // get the current observer\n\n\n  get observer() {\n    return this.store.observer;\n  } // get the observers\n\n\n  get observers() {\n    return this.stores.map(store => store.observer);\n  } // get the current history\n\n\n  get history() {\n    return this.store.history;\n  } // get the current changes\n\n\n  get changes() {\n    return this.store.changes;\n  } // set the current changes\n\n\n  set changes(changes) {\n    this.store.changes = changes;\n  } // save changes\n\n\n  commit() {\n    this.store.commit();\n  } // load all changes\n\n\n  loadChanges() {\n    this.store.loadChanges();\n  } // unload all changes\n\n\n  unloadChanges() {\n    this.store.unloadChanges();\n  } // load the next json\n\n\n  loadNext() {\n    if (this.index < this.stores.length - 1) this.index++;\n  } // load the prior json\n\n\n  loadPrior() {\n    if (this.index > 0) this.index--;\n  }\n\n}\n/* Global */\n;\n\n(function () {\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this; // Export the Underscore object for **CommonJS**, with backwards-compatibility\n  // for the old `require()` API. If we're not in CommonJS\n\n  if (typeof module !== 'undefined' && module.exports) {\n    const Blockly = require('blockly');\n\n    module.exports = Gamepad;\n    root.Blockly = Blockly;\n    Blockly.Gamepad = Gamepad;\n  } else {\n    if (typeof Blockly !== undefined) Blockly.Gamepad = Gamepad;\n  }\n})();\n/* load the setting */\n\n\nGamepad.setting(); //export default Gamepad","map":{"version":3,"sources":["C:/Users/vingt/Dropbox/AION/BLUEPRINTS/hexlibrium/node_modules/blockly-gamepad/src/gamepad.js"],"names":["Gamepad","constructor","options","worker","Worker","blocklyManager","BlocklyManager","jsonManager","JsonManager","undefined","reset","onRequest","level","observer","init","levels","observers","Array","isArray","Error","request","back","old","isCoding","highlight","setHighlight","id","method","state","loadNext","loadPrior","unloadChanges","loadChanges","result","game","commit","setGame","thisArg","apply","arguments","load","times","isNaN","code","evalContext","getInstance","getBlocksNumber","setToolbox","forward","stop","go","backward","play","removeBreakpoint","freeQueue","start","pause","togglePlay","isRunning","debug","promise","setBreakpoint","save","name","restore","version","Symbol","utils","xml2json","xml","tab","X","toObj","o","nodeType","attributes","length","i","nodeName","nodeValue","toString","firstChild","textChild","cdataChild","hasElementChild","n","nextSibling","match","removeWhite","escape","innerXml","documentElement","toJson","ind","json","join","arr","m","node","s","innerHTML","asXml","c","txt","replace","e","normalize","nxt","removeChild","json2xml","toXml","v","hasChild","toLowerCase","charAt","substr","filter","hasCategory","hasBlock","procedure","variable","CATEGORY","splice","BLOCK","blocks","includes","jsonArray","type","block","hasStatements","hastemplate","statements","Object","values","template","Blockly","JavaScript","js","args","order","push","Blocks","javascript","defineBlocksWithJsonArray","wrap","oldGenerator","a","b","variableDB_","getName","getFieldValue","Procedures","NAME_TYPE","statementToCode","STATEMENT_PREFIX","d","prefixLines","INDENT","INFINITE_LOOP_TRAP","valueToCode","ORDER_NONE","f","arguments_","Variables","scrub_","definitions_","slice","build","data","JSON","stringify","_args","_statements","arg","get","_","field","input","value","statement","repeat","promiseWrapper","resolve","Promise","res","isPending","isFulfilled","errorHandler","error","setting","Trashcan","prototype","clear","contents_","Scrollbar","scrollbarThickness","procedures_defreturn","procedures_defnoreturn","procedures_callreturn","ORDER_COMMA","ORDER_FUNCTION_CALL","procedures_callnoreturn","addReservedWords","hasOwnProperty","inputs","toolbox","context","customHighlight","workspace","getMainWorkspace","addChangeListener","event","Events","BLOCK_MOVE","removeHighlight","workspaceToCode","getTopBlocks","dispose","setTimeout","trashcan","parentBlock","newBlock","setDeletable","startHat_","initSvg","render","setMovable","moveBy","scrollX","scrollY","undoStack_","parse","XML","updateToolbox","document","querySelector","classList","add","highlightBlock","getElementsByClassName","remove","getAllBlocks","total","Storage","Xml","workspaceToDom","localStorage","setItem","domToText","getItem","textToDom","domToWorkspace","resize","svgResize","History","history","update","index","next","prior","current","Queue","requests","closed","setListener","listener","reject","setted","close","then","open","shift","set","Asynchronizer","sync","onRun","onReset","async","handler","obj","prop","getOwnPropertySymbols","run","Proxy","defineProperties","assign","getOwnPropertyDescriptors","asynchronizer","queue","debugger","forEach","setRequest","p","manage","finished","generated","completed","return","ac","property","defineProperty","CONTEXT","eval","err","console","INSERT","UPDATE","DELETE","POP","PUSH","SHIFT","UNSHIFT","REVERSE","nonObservables","Date","Blob","Number","String","Boolean","SyntaxError","TypeError","URIError","Function","RegExp","observableDefinition","revoke","observe","systemObserver","has","unobserve","l","size","delete","prepareArray","source","item","target","ArrayObserver","ownKey","parent","proxy","ObjectObserver","prepareObject","keys","key","callObservers","changes","relevantChanges","getAncestorInfo","self","tmp","l1","l2","isRevoked","path","getLastProp","loadChange","change","pop","unshift","reverse","unloadChange","oldValue","observeJson","observed","Observer","properties","cloningFunction","targetClone","Map","revokable","revocable","newValue","ad","tmpObserved","object","deleteProperty","proxiedArrayMethods","proxiedPop","popResult","proxiedPush","pushContent","pushResult","initialLength","Reflect","proxiedShift","shiftResult","proxiedUnshift","unshiftContent","unshiftResult","from","proxiedReverse","sort","proxiedSort","comparator","fill","proxiedFill","normArgs","argLen","end","prev","tarLen","tmpTarget","proxiedSplice","spliceContent","spliceResult","startIndex","removed","inserted","splLen","Math","max","bind","Store","stores","freeze","store","map","root","module","exports","require"],"mappings":"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","sourcesContent":["// /* Gamepad class */\r\n// class ThreeScene extends Component {\r\n\r\n//     componentDidMount() {\r\n\r\nconst Gamepad = class {\r\n    constructor(options) {\r\n        options = options || {};\r\n\r\n        // set the managers\r\n        this.worker = new Gamepad.Worker();\r\n        this.blocklyManager = new Gamepad.BlocklyManager(options);\r\n        this.jsonManager = new Gamepad.JsonManager();\r\n\r\n        this['magicJson'] = options['magicJson'] === true;\r\n        this['highlight'] = options['customHighlight'] !== undefined;\r\n\r\n        this.reset();\r\n        this.worker.onRequest(this, this.onRequest);\r\n    }\r\n\r\n    // level getter\r\n    get level() {\r\n        return this.jsonManager.observer;\r\n    }\r\n\r\n    // level setter\r\n    set level(level) {\r\n        this.jsonManager.init([level]);\r\n    }\r\n\r\n    // levels getter\r\n    get levels() {\r\n        return this.jsonManager.observers;\r\n    }\r\n\r\n    // levels setter\r\n    set levels(levels) {\r\n        if (!Array.isArray(levels))\r\n            throw new Error('levels argument must be an array');\r\n        this.jsonManager.init(levels);\r\n    }\r\n\r\n    // worker requests's handler\r\n    onRequest(request, back, old) {\r\n        // if the workspace has changed since the last time the code was loaded\r\n        // the block is not highlighted\r\n        if (!this.blocklyManager.isCoding && this.highlight) this.blocklyManager.setHighlight(request.id);\r\n\r\n        // if the current level is finished and there's a forward 'START' request (must be forward) the next level is loaded\r\n        // if there's only one level this method is never triggered\r\n        if (request.method == Gamepad['STATES']['STARTED'] &&\r\n            (this.state == Gamepad['STATES']['FINISHED'] || this.state == Gamepad['STATES']['COMPLETED']) &&\r\n            !back) this.jsonManager.loadNext();\r\n\r\n        // if the current level is started and there's a 'FINISHED' request (must be backward) the prior level is loaded\r\n        // if there's only one level this method is never triggered\r\n        if ((request.method == Gamepad['STATES']['FINISHED'] || request.method == Gamepad['STATES']['COMPLETED']) &&\r\n            this.state == Gamepad['STATES']['STARTED'] &&\r\n            back) this.jsonManager.loadPrior();\r\n\r\n        // if the request is not old and magicJson is enabled\r\n        if (this['magicJson'] && old) {\r\n            // if it's a backward request\r\n            if (back)\r\n                // unload the changes\r\n                this.jsonManager.unloadChanges();\r\n            // if this is a forward request\r\n            else\r\n                // load the changes\r\n                this.jsonManager.loadChanges();\r\n        }\r\n\r\n        // send the request to the game\r\n        let result = this.game(request, back, old);\r\n\r\n        // update the state \r\n        if (request.method == Gamepad['STATES']['STARTED'] ||\r\n            request.method == Gamepad['STATES']['FINISHED'] ||\r\n            request.method == Gamepad['STATES']['COMPLETED']\r\n        ) this.state = request.method;\r\n\r\n        // if there's the json manager and the request is not old the changes are saved\r\n        if (this['magicJson'] && !old)\r\n            this.jsonManager.commit();\r\n\r\n        // return the game result\r\n        return result;\r\n    }\r\n\r\n    // set the requests's handler\r\n    setGame(thisArg, method) {\r\n        // it must be a function\r\n        if (typeof method != 'function') throw new Error('method is not a function');\r\n\r\n        this.game = function () {\r\n            return method.apply(thisArg, [...arguments]);\r\n        }\r\n    }\r\n\r\n    // load the code n times\r\n    load(times) {\r\n        // reset the state of the game\r\n        this.state = Gamepad['STATES']['STARTED'];\r\n\r\n        // if times is setted it must be a number greater than 0\r\n        if ((times !== undefined) && (isNaN(times) || times < 1))\r\n            throw new Error('times must be a number greater than 0.');\r\n\r\n        // if times is not setted load code 1 times\r\n        times = times || 1;\r\n\r\n        // reset the workspace\r\n        this.worker.reset();\r\n        // get the code\r\n        let code = this.blocklyManager.code(times);\r\n\r\n        // reset the jsonManager\r\n        this.jsonManager.reset();\r\n\r\n        // load the code\r\n        Gamepad.evalContext(code, this.worker.getInstance());\r\n\r\n        // return the blocks number\r\n        return this.blocklyManager.getBlocksNumber();\r\n    }\r\n\r\n    // reset the gamepad\r\n    reset() {\r\n        // reset the state of the game\r\n        this.state = Gamepad['STATES']['STARTED'];\r\n        // reset the jsonManager\r\n        this.jsonManager.reset();\r\n        // reset the worker\r\n        this.worker.reset();\r\n        // reset the blocklyManager\r\n        this.blocklyManager.reset();\r\n    }\r\n\r\n    // update the toolbox\r\n    setToolbox(options) {\r\n        this.blocklyManager.setToolbox(options);\r\n    }\r\n\r\n    // generate a forward request\r\n    forward() {\r\n        // stop the worker if it was running\r\n        this.worker.stop();\r\n        // send a forward request\r\n        return this.worker.go(false);\r\n    }\r\n\r\n    // create a backward request\r\n    backward() {\r\n        // stop the worker if it was running\r\n        this.worker.stop();\r\n        // send a backward request\r\n        return this.worker.go(true);\r\n    }\r\n\r\n    // play the game (back ? backward : forward)\r\n    play(back) {\r\n        // remove the breakpoint\r\n        this.worker.removeBreakpoint();\r\n        // free the queue of requests\r\n        this.worker.freeQueue();\r\n        // start the worker\r\n        this.worker.start(back);\r\n    }\r\n\r\n    // pause the game\r\n    pause() {\r\n        // stop the worker\r\n        this.worker.stop();\r\n        // free the queue of requests\r\n        this.worker.freeQueue();\r\n    }\r\n\r\n    // toggle play\r\n    togglePlay() {\r\n        if (this.worker.isRunning) this.pause();\r\n        else this.play(this.worker.back);\r\n    }\r\n\r\n    // reach a breakpoint\r\n    debug(id, back) {\r\n        let promise = this.worker.setBreakpoint(id);\r\n        this.worker.start(back);\r\n        return promise;\r\n    }\r\n\r\n    // save the workspace\r\n    save(name) {\r\n        this.blocklyManager.save(name);\r\n    }\r\n\r\n    // restore the workspace\r\n    restore(name) {\r\n        this.blocklyManager.restore(name);\r\n    }\r\n\r\n    // version\r\n    static version() {\r\n        return '1.0.1';\r\n    }\r\n}\r\n\r\n/* Gamepad symbol */\r\n// a global symbol (used in Observer and Asynchronizer classes)\r\nGamepad['SYMBOL'] = Symbol('blockly-gamepad');\r\n\r\n/* Gamebad toolbox */\r\n// will contain a json that represent the toolbox\r\nGamepad['TOOLBOX'] = {}\r\n\r\n/* Gamebad context */\r\n// global context that the code generator can access\r\nGamepad['CONTEXT'] = {}\r\n\r\n/* Gamebad inputs */\r\n// will contain some inputs\r\nGamepad['INPUTS'] = {}\r\n\r\n/* Gamepad errors */\r\n// strings that represents errors\r\nGamepad['ERRORS'] = {\r\n    // this error means that the instance that throw it has been resetted\r\n    // used by Asynchronizer and the Queue\r\n    'CLOSED': 'CLOSED',\r\n    // this error is throwed by the Worker to end a level\r\n    'FINISHED': 'FINISHED',\r\n    // this error is throwed by the Worker to end all the levels\r\n    'COMPLETED': 'COMPLETED'\r\n}\r\n\r\n/* Gamepad states */\r\n// states are passed in the request .method field\r\nGamepad['STATES'] = {\r\n    // a level is started\r\n    'STARTED': 'STARTED',\r\n    // a level is finished\r\n    'FINISHED': 'FINISHED',\r\n    // all the levels are finished\r\n    'COMPLETED': 'COMPLETED'\r\n}\r\n\r\n/* Gamepad blocks */\r\nGamepad['BLOCKS'] = {\r\n    // the type of the start block\r\n    'START': 'start'\r\n}\r\n\r\n/* Gamepad templates */\r\n// templates are used to generate custom blocks\r\nGamepad['TEMPLATES'] = {\r\n    'WHILE': 'while',\r\n    'DO_WHILE': 'do_while',\r\n    'IF': 'if',\r\n    'IF_ELSE': 'if_else'\r\n}\r\n\r\n/* Gamepad utils */\r\nGamepad.utils = {\r\n    /* xml to json */\r\n    xml2json: function (xml, tab) {\r\n        var X = {\r\n            toObj: function (xml) {\r\n                var o = {}\r\n                if (xml.nodeType == 1) {\r\n                    if (xml.attributes.length)\r\n                        for (var i = 0; i < xml.attributes.length; i++)\r\n                            o[\"@\" + xml.attributes[i].nodeName] = (xml.attributes[i].nodeValue || \"\").toString();\r\n                    if (xml.firstChild) {\r\n                        var textChild = 0,\r\n                            cdataChild = 0,\r\n                            hasElementChild = false;\r\n                        for (var n = xml.firstChild; n; n = n.nextSibling) {\r\n                            if (n.nodeType == 1) hasElementChild = true;\r\n                            else if (n.nodeType == 3 && n.nodeValue.match(/[^ \\f\\n\\r\\t\\v]/)) textChild++;\r\n                            else if (n.nodeType == 4) cdataChild++;\r\n                        }\r\n                        if (hasElementChild) {\r\n                            if (textChild < 2 && cdataChild < 2) {\r\n                                X.removeWhite(xml);\r\n                                for (var n = xml.firstChild; n; n = n.nextSibling) {\r\n                                    if (n.nodeType == 3)\r\n                                        o[\"#text\"] = X.escape(n.nodeValue);\r\n                                    else if (n.nodeType == 4)\r\n                                        o[\"#cdata\"] = X.escape(n.nodeValue);\r\n                                    else if (o[n.nodeName]) {\r\n                                        if (o[n.nodeName] instanceof Array)\r\n                                            o[n.nodeName][o[n.nodeName].length] = X.toObj(n);\r\n                                        else\r\n                                            o[n.nodeName] = [o[n.nodeName], X.toObj(n)];\r\n                                    } else\r\n                                        o[n.nodeName] = X.toObj(n);\r\n                                }\r\n                            } else {\r\n                                if (!xml.attributes.length)\r\n                                    o = X.escape(X.innerXml(xml));\r\n                                else\r\n                                    o[\"#text\"] = X.escape(X.innerXml(xml));\r\n                            }\r\n                        } else if (textChild) {\r\n                            if (!xml.attributes.length)\r\n                                o = X.escape(X.innerXml(xml));\r\n                            else\r\n                                o[\"#text\"] = X.escape(X.innerXml(xml));\r\n                        } else if (cdataChild) {\r\n                            if (cdataChild > 1)\r\n                                o = X.escape(X.innerXml(xml));\r\n                            else\r\n                                for (var n = xml.firstChild; n; n = n.nextSibling)\r\n                                    o[\"#cdata\"] = X.escape(n.nodeValue);\r\n                        }\r\n                    }\r\n                    if (!xml.attributes.length && !xml.firstChild) o = null;\r\n                } else if (xml.nodeType == 9) {\r\n                    o = X.toObj(xml.documentElement);\r\n                }\r\n                return o;\r\n            },\r\n            toJson: function (o, name, ind) {\r\n                var json = name ? (\"\\\"\" + name + \"\\\"\") : \"\";\r\n                if (o instanceof Array) {\r\n                    for (var i = 0, n = o.length; i < n; i++)\r\n                        o[i] = X.toJson(o[i], \"\", ind + \"\\t\");\r\n                    json += (name ? \":[\" : \"[\") + (o.length > 1 ? (\"\\n\" + ind + \"\\t\" + o.join(\",\\n\" + ind + \"\\t\") + \"\\n\" + ind) : o.join(\"\")) + \"]\";\r\n                } else if (o == null)\r\n                    json += (name && \":\") + \"null\";\r\n                else if (typeof (o) == \"object\") {\r\n                    var arr = [];\r\n                    for (var m in o)\r\n                        arr[arr.length] = X.toJson(o[m], m, ind + \"\\t\");\r\n                    json += (name ? \":{\" : \"{\") + (arr.length > 1 ? (\"\\n\" + ind + \"\\t\" + arr.join(\",\\n\" + ind + \"\\t\") + \"\\n\" + ind) : arr.join(\"\")) + \"}\";\r\n                } else if (typeof (o) == \"string\")\r\n                    json += (name && \":\") + \"\\\"\" + o.toString() + \"\\\"\";\r\n                else\r\n                    json += (name && \":\") + o.toString();\r\n                return json;\r\n            },\r\n            innerXml: function (node) {\r\n                var s = \"\"\r\n                if (\"innerHTML\" in node)\r\n                    s = node.innerHTML;\r\n                else {\r\n                    var asXml = function (n) {\r\n                        var s = \"\";\r\n                        if (n.nodeType == 1) {\r\n                            s += \"<\" + n.nodeName;\r\n                            for (var i = 0; i < n.attributes.length; i++)\r\n                                s += \" \" + n.attributes[i].nodeName + \"=\\\"\" + (n.attributes[i].nodeValue || \"\").toString() + \"\\\"\";\r\n                            if (n.firstChild) {\r\n                                s += \">\";\r\n                                for (var c = n.firstChild; c; c = c.nextSibling)\r\n                                    s += asXml(c);\r\n                                s += \"</\" + n.nodeName + \">\";\r\n                            } else\r\n                                s += \"/>\";\r\n                        } else if (n.nodeType == 3)\r\n                            s += n.nodeValue;\r\n                        else if (n.nodeType == 4)\r\n                            s += \"<![CDATA[\" + n.nodeValue + \"]]>\";\r\n                        return s;\r\n                    }\r\n                    for (var c = node.firstChild; c; c = c.nextSibling)\r\n                        s += asXml(c);\r\n                }\r\n                return s;\r\n            },\r\n            escape: function (txt) {\r\n                return txt.replace(/[\\\\]/g, \"\\\\\\\\\")\r\n                    .replace(/[\\\"]/g, '\\\\\"')\r\n                    .replace(/[\\n]/g, '\\\\n')\r\n                    .replace(/[\\r]/g, '\\\\r');\r\n            },\r\n            removeWhite: function (e) {\r\n                e.normalize();\r\n                for (var n = e.firstChild; n;) {\r\n                    if (n.nodeType == 3) {\r\n                        if (!n.nodeValue.match(/[^ \\f\\n\\r\\t\\v]/)) {\r\n                            var nxt = n.nextSibling;\r\n                            e.removeChild(n);\r\n                            n = nxt;\r\n                        } else\r\n                            n = n.nextSibling;\r\n                    } else if (n.nodeType == 1) {\r\n                        X.removeWhite(n);\r\n                        n = n.nextSibling;\r\n                    } else\r\n                        n = n.nextSibling;\r\n                }\r\n                return e;\r\n            }\r\n        }\r\n        if (xml.nodeType == 9)\r\n            xml = xml.documentElement;\r\n        var json = X.toJson(X.toObj(X.removeWhite(xml)), xml.nodeName, \"\\t\");\r\n        return \"{\\n\" + tab + (tab ? json.replace(/\\t/g, tab) : json.replace(/\\t|\\n/g, \"\")) + \"\\n}\";\r\n    },\r\n    /* json to xml */\r\n    json2xml: function (o, tab) {\r\n        var toXml = function (v, name, ind) {\r\n            var xml = \"\";\r\n            if (v instanceof Array) {\r\n                for (var i = 0, n = v.length; i < n; i++)\r\n                    xml += ind + toXml(v[i], name, ind + \"\\t\") + \"\\n\";\r\n            } else if (typeof (v) == \"object\") {\r\n                var hasChild = false;\r\n                xml += ind + \"<\" + name.toLowerCase();\r\n                for (var m in v) {\r\n                    if (m.charAt(0) == \"@\")\r\n                        xml += \" \" + m.substr(1) + \"=\\\"\" + v[m].toString() + \"\\\"\";\r\n                    else\r\n                        hasChild = true;\r\n                }\r\n                xml += hasChild ? \">\" : \"/>\";\r\n                if (hasChild) {\r\n                    for (var m in v) {\r\n                        if (m == \"#text\")\r\n                            xml += v[m];\r\n                        else if (m == \"#cdata\")\r\n                            xml += \"<![CDATA[\" + v[m] + \"]]>\";\r\n                        else if (m.charAt(0) != \"@\")\r\n                            xml += toXml(v[m], m, ind + \"\\t\");\r\n                    }\r\n                    xml += (xml.charAt(xml.length - 1) == \"\\n\" ? ind : \"\") + \"</\" + name.toLowerCase() + \">\";\r\n                }\r\n            } else {\r\n                xml += ind + \"<\" + name + \">\" + v.toString() + \"</\" + name + \">\";\r\n            }\r\n            return xml;\r\n        },\r\n            xml = \"\";\r\n        for (var m in o)\r\n            xml += toXml(o[m], m.toString().toLowerCase(), \"\");\r\n        return tab ? xml.replace(/\\t/g, tab) : xml.replace(/\\t|\\n/g, \"\");\r\n    },\r\n    /* filter the toolbox json */\r\n    filter: function (json, options) {\r\n        let hasCategory = false,\r\n            hasBlock = false;\r\n\r\n        // show/hide PROCEDURE custom category\r\n        if (json['@custom'] == \"PROCEDURE\") {\r\n            return options.procedure !== false;\r\n        }\r\n\r\n        // show/hide VARIABLE custom category\r\n        if (json['@custom'] == \"VARIABLE\") {\r\n            return options.variable !== false;\r\n        }\r\n\r\n        if (json.CATEGORY) {\r\n            let i;\r\n            for (i = 0; i < json.CATEGORY.length; i++) {\r\n                if (!Gamepad.utils.filter(json.CATEGORY[i], options)) {\r\n                    json.CATEGORY.splice(i, 1);\r\n                    i--;\r\n                }\r\n            }\r\n\r\n            // there's at least one category\r\n            if (i > 0) hasCategory = true;\r\n        }\r\n\r\n        if (json.BLOCK) {\r\n            let i;\r\n            for (i = 0; i < json.BLOCK.length; i++) {\r\n                // if the block has to be visualized\r\n                if (!options.blocks.includes(json.BLOCK[i]['@type'])) {\r\n                    json.BLOCK.splice(i, 1);\r\n                    i--;\r\n                }\r\n            }\r\n\r\n            // there's at least one block\r\n            if (i > 0) hasBlock = true;\r\n        }\r\n\r\n        // there's something to render in the toolbox\r\n        return hasCategory || hasBlock;\r\n    },\r\n    /* block generator */\r\n    blocks: function (blocks) {\r\n        let jsonArray = [];\r\n\r\n        for (let type in blocks) {\r\n            let block = blocks[type],\r\n                hasStatements = false,\r\n                hastemplate = false;\r\n\r\n            if ('statements' in block) {\r\n                // statements must be an array of string\r\n                if (!Array.isArray(block.statements) || block.statements.length == 0)\r\n                    throw new Error('statements must be an array of string');\r\n\r\n                hasStatements = true;\r\n            }\r\n\r\n            if ('template' in block) {\r\n                // template must be one of the Gamepad['TEMPLATES']\r\n                if (!Object.values(Gamepad['TEMPLATES']).includes(block.template))\r\n                    throw new Error('template must be one of Gamepad[\\'TEMPLATES\\']');\r\n\r\n                hastemplate = true;\r\n            }\r\n\r\n            // a block must have both or none\r\n            if (hastemplate && !hasStatements) throw new Error('a template block require at least a statement');\r\n            if (!hastemplate && hasStatements) throw new Error('statements setted without the template');\r\n\r\n            // load the javascript\r\n            Blockly.JavaScript['' + type] = Gamepad.utils.js(block.method, block.args, block.order, block.template, block.statements);\r\n\r\n            // init the block with the json or the javascript\r\n            if ('json' in block) {\r\n                block.json.type = type;\r\n                jsonArray.push(block.json);\r\n            } else if ('javascript' in block) {\r\n                Blockly.Blocks[type] = block.javascript;\r\n            }\r\n        }\r\n\r\n        Blockly.defineBlocksWithJsonArray(jsonArray);\r\n    },\r\n    /* wrap standard blocks to generate requests */\r\n    wrap: function (blocks) {\r\n        if (!Array.isArray(blocks)) throw new Error('blocks must be an array of block types');\r\n\r\n        for (let type of blocks) {\r\n            if (!(type in Blockly.JavaScript)) throw new Error('The following type does not exist: ' + type);\r\n\r\n            let oldGenerator = Blockly.JavaScript[type];\r\n\r\n            switch (type) {\r\n                // procedures wrap\r\n                case 'procedures_defnoreturn': ;\r\n                case 'procedures_defreturn': Blockly.JavaScript[type] = function (a) {\r\n                    var b = Blockly.JavaScript.variableDB_.getName(a.getFieldValue(\"NAME\"), Blockly.Procedures.NAME_TYPE),\r\n                        c = Blockly.JavaScript.statementToCode(a, \"STACK\");\r\n                    if (Blockly.JavaScript.STATEMENT_PREFIX) {\r\n                        var d = a.id.replace(/\\$/g, \"$$$$\");\r\n                        c = Blockly.JavaScript.prefixLines(Blockly.JavaScript.STATEMENT_PREFIX.replace(/%1/g, \"'\" + d + \"'\"), Blockly.JavaScript.INDENT) + c\r\n                    }\r\n                    Blockly.JavaScript.INFINITE_LOOP_TRAP && (c = Blockly.JavaScript.INFINITE_LOOP_TRAP.replace(/%1/g, \"'\" + a.id + \"'\") +\r\n                        c);\r\n                    (d = Blockly.JavaScript.valueToCode(a, \"RETURN\", Blockly.JavaScript.ORDER_NONE) || \"\") && (d = Blockly.JavaScript.INDENT + \"return \" + d + \";\\n\");\r\n                    for (var e = [], f = 0; f < a.arguments_.length; f++) e[f] = Blockly.JavaScript.variableDB_.getName(a.arguments_[f], Blockly.Variables.NAME_TYPE);\r\n\r\n                    c = \"async function \" + b + \"(\" + e.join(\", \") + \") {\\n\" +\r\n                        Gamepad.utils.request(type, [b], a.id) +\r\n                        c + d + \"\\n\" +\r\n                        \"}\";\r\n                    c = Blockly.JavaScript.scrub_(a, c);\r\n                    Blockly.JavaScript.definitions_[\"%\" + b] = c;\r\n\r\n                    return null\r\n                }; break;\r\n                // default wrap\r\n                default: Blockly.JavaScript[type] = function (block) {\r\n                    let result = oldGenerator.apply(this, [...arguments]),\r\n                        request = Gamepad.utils.request(type, [], block.id);\r\n\r\n                    // if there's a order\r\n                    Array.isArray(result)\r\n                        ? result[0] = request.slice(0, -1) + '.then(async () => ' + result[0] + ' )\\n'\r\n                        : result = request + result;\r\n\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n    },\r\n    /* build a request object */\r\n    build: function (method, args, id, data) {\r\n        // check the arguments\r\n        if (typeof method != 'string') method = '';\r\n        if (!Array.isArray(args)) args = [];\r\n        if (typeof method != 'string') id = '';\r\n\r\n        return data ? { method, args, id, data } : { method, args, id }\r\n    },\r\n    /* request string builder */\r\n    request: function (method, args, id, order) {\r\n        // check the arguments\r\n        let request = Gamepad.utils.build(method, args, id);\r\n\r\n        method = `method: \\'${request.method}\\'`;\r\n        args = `args: ${JSON.stringify(request.args)}`;\r\n        id = `id: \\'${request.id}\\'`;\r\n\r\n        // build the request\r\n        let result = `await worker.setRequest({ ${method}, ${args}, ${id} })\\n`;\r\n\r\n        return (order != undefined) ? [result, order] : result;\r\n    },\r\n    /* javascript string builder */\r\n    js: function (method, args, order, template, statements) {\r\n        // check the arguments\r\n        args = Array.isArray(args) ? args : [];\r\n        statements = Array.isArray(statements) ? statements : [];\r\n\r\n        // code generator function\r\n        return function (block) {\r\n            let _args = [],\r\n                _statements = [];\r\n\r\n            // build the args\r\n            for (let arg of args) {\r\n                let get = (typeof arg.get == 'function') ? arg.get : _ => _;\r\n\r\n                // field\r\n                if (arg.field != undefined) {\r\n                    _args.push(get(block.getFieldValue(arg.field)));\r\n                    // input\r\n                } else if (arg.input != undefined) {\r\n                    _args.push(get(Gamepad['INPUTS'][arg.input]));\r\n                    // value\r\n                } else if (arg.value != undefined) {\r\n                    _args.push(get(arg.value));\r\n                }\r\n            }\r\n\r\n            // get the code from the input_statement fields\r\n            for (let statement of statements) {\r\n                _statements.push(Blockly.JavaScript.statementToCode(block, statement));\r\n            }\r\n\r\n            // build the template\r\n            switch (template) {\r\n                case Gamepad['TEMPLATES']['WHILE']:\r\n                    return 'while(' + Gamepad.utils.request(method, _args, block.id) + '){\\n' + _statements[0] + '}';\r\n                case Gamepad['TEMPLATES']['DO_WHILE']:\r\n                    return 'do{' + _statements[0] + '}while{\\n' + Gamepad.utils.request(method, _args, block.id) + '}';\r\n                case Gamepad['TEMPLATES']['IF']:\r\n                    return 'if(' + Gamepad.utils.request(method, _args, block.id) + '){\\n' + _statements[0] + '}';\r\n                case Gamepad['TEMPLATES']['IF_ELSE']:\r\n                    return 'if(' + Gamepad.utils.request(method, _args, block.id) + '){\\n' + _statements[0] + '}else{' + _statements[1] + '}';\r\n                // simple request\r\n                default:\r\n                    return Gamepad.utils.request(method, _args, block.id, order);\r\n            }\r\n        }\r\n    },\r\n    /* code string builder */\r\n    code: function (code, times) {\r\n        // throwing Gamepad[\"ERRORS\"][\"FINISHED\"] will end a level\r\n        // throwing Gamepad[\"ERRORS\"][\"COMPLETED\"] will end all the levels\r\n\r\n        //  try{\r\n        //\r\n        //      try{\r\n        //          await worker.setRequest({method: Gamepad[\"STATES\"][\"STARTED\"], id: Gamepad[\"STATES\"][\"STARTED\"]});\r\n        //          ...\r\n        //          await worker.setRequest({method: Gamepad[\"STATES\"][\"FINISHED\"], id: Gamepad[\"STATES\"][\"FINISHED\"]});\r\n        //      }catch(error){ \r\n        //          if(error != Gamepad[\"ERRORS\"][\"FINISHED\"]) throw error; \r\n        //      }\r\n        //\r\n        //      try{\r\n        //          await worker.setRequest({method: Gamepad[\"STATES\"][\"STARTED\"], id: Gamepad[\"STATES\"][\"STARTED\"]});\r\n        //          ...\r\n        //          await worker.setRequest({method: Gamepad[\"STATES\"][\"FINISHED\"], id: Gamepad[\"STATES\"][\"FINISHED\"]});\r\n        //      }catch(error){ \r\n        //          if(error != Gamepad[\"ERRORS\"][\"FINISHED\"]) throw error; \r\n        //      }\r\n        //\r\n        //      await worker.setRequest({method: Gamepad[\"STATES\"][\"COMPLETED\"], id: Gamepad[\"STATES\"][\"COMPLETED\"]});\r\n        //\r\n        //  }catch(error){\r\n        //      if(error != Gamepad[\"ERRORS\"][\"COMPLETED\"]) throw error;\r\n        //  }\r\n\r\n        code = ('try {\\n' +\r\n            Gamepad.utils.request(Gamepad['STATES']['STARTED'], [], Gamepad['STATES']['STARTED']) +\r\n            code +\r\n            Gamepad.utils.request(Gamepad['STATES']['FINISHED'], [], Gamepad['STATES']['FINISHED']) +\r\n            '} catch(error) { if(error != Gamepad[\"ERRORS\"][\"FINISHED\"]) throw error; }\\n').repeat(times);\r\n\r\n        return ('async function f() {\\n' +\r\n            '   try{\\n' +\r\n            code +\r\n            // send the COMPLETED request only if there are more levels\r\n            (times > 1 ? Gamepad.utils.request(Gamepad['STATES']['COMPLETED'], [], Gamepad[\"STATES\"][\"COMPLETED\"]) : '') +\r\n            '       worker.close();\\n' +\r\n            '   }catch(error){ if(error != Gamepad[\"ERRORS\"][\"COMPLETED\"]) { throw error; } }\\n' +\r\n            '   }\\n' +\r\n            'f();');\r\n    },\r\n    /* promise wrapper */\r\n    promiseWrapper: function () {\r\n\r\n        let resolve,\r\n            promise = new Promise(res => {\r\n                resolve = res\r\n            });\r\n\r\n        var isPending = true;\r\n        var isFulfilled = false;\r\n\r\n        // if the promise is fulfilled\r\n        promise.isFulfilled = function () {\r\n            return isFulfilled;\r\n        }\r\n        // if the promise is pending\r\n        promise.isPending = function () {\r\n            return isPending;\r\n        }\r\n        // resolve the promise\r\n        promise.resolve = function (value) {\r\n            isPending = false;\r\n            isFulfilled = true;\r\n            resolve(value);\r\n        }\r\n\r\n        return promise;\r\n    },\r\n    /* error handler */\r\n    errorHandler: function (error) {\r\n        if (error !== Gamepad['ERRORS']['CLOSED'])\r\n            throw error;\r\n    }\r\n}\r\n\r\n/* Gamepad settings loader */\r\nGamepad.setting = function () {\r\n    // add clear method to the trashcan\r\n    Blockly.Trashcan.prototype.clear = function () {\r\n        this.contents_ = new Array();\r\n    }\r\n\r\n    // set scrollbar thickness\r\n    Blockly.Scrollbar.scrollbarThickness = 12;\r\n\r\n    // custom code generators for procedures\r\n    Blockly.JavaScript.procedures_defreturn = function (a) {\r\n        var b = Blockly.JavaScript.variableDB_.getName(a.getFieldValue(\"NAME\"), Blockly.Procedures.NAME_TYPE),\r\n            c = Blockly.JavaScript.statementToCode(a, \"STACK\");\r\n        if (Blockly.JavaScript.STATEMENT_PREFIX) {\r\n            var d = a.id.replace(/\\$/g, \"$$$$\");\r\n            c = Blockly.JavaScript.prefixLines(Blockly.JavaScript.STATEMENT_PREFIX.replace(/%1/g, \"'\" + d + \"'\"), Blockly.JavaScript.INDENT) + c\r\n        }\r\n        Blockly.JavaScript.INFINITE_LOOP_TRAP && (c = Blockly.JavaScript.INFINITE_LOOP_TRAP.replace(/%1/g, \"'\" + a.id + \"'\") +\r\n            c);\r\n        (d = Blockly.JavaScript.valueToCode(a, \"RETURN\", Blockly.JavaScript.ORDER_NONE) || \"\") && (d = Blockly.JavaScript.INDENT + \"return \" + d + \";\\n\");\r\n        for (var e = [], f = 0; f < a.arguments_.length; f++) e[f] = Blockly.JavaScript.variableDB_.getName(a.arguments_[f], Blockly.Variables.NAME_TYPE);\r\n\r\n        c = \"async function \" + b + \"(\" + e.join(\", \") + \") {\\n\" +\r\n            c + d + \"\\n\" +\r\n            \"}\";\r\n        c = Blockly.JavaScript.scrub_(a, c);\r\n        Blockly.JavaScript.definitions_[\"%\" + b] = c;\r\n\r\n        return null;\r\n    }\r\n    Blockly.JavaScript.procedures_defnoreturn = Blockly.JavaScript.procedures_defreturn;\r\n    Blockly.JavaScript.procedures_callreturn = function (a) {\r\n        for (var b = Blockly.JavaScript.variableDB_.getName(a.getFieldValue(\"NAME\"), Blockly.Procedures.NAME_TYPE), c = [], d = 0; d < a.arguments_.length; d++) c[d] = Blockly.JavaScript.valueToCode(a, \"ARG\" + d, Blockly.JavaScript.ORDER_COMMA) || \"null\";\r\n        return [\"await \" + b + \"(\" + c.join(\", \") + \")\", Blockly.JavaScript.ORDER_FUNCTION_CALL]\r\n    }\r\n    Blockly.JavaScript.procedures_callnoreturn = function (a) {\r\n        for (var b = Blockly.JavaScript.variableDB_.getName(a.getFieldValue(\"NAME\"), Blockly.Procedures.NAME_TYPE), c = [], d = 0; d < a.arguments_.length; d++) c[d] = Blockly.JavaScript.valueToCode(a, \"ARG\" + d, Blockly.JavaScript.ORDER_COMMA) || \"null\";\r\n        return \"await \" + b + \"(\" + c.join(\", \") + \");\\n\"\r\n    }\r\n\r\n    Blockly.JavaScript[Gamepad['BLOCKS']['START']] = function () {\r\n        return '';\r\n    }\r\n\r\n    // set reserved words\r\n    Blockly.JavaScript.addReservedWords('Blockly,CONTEXT,worker,code,reject,resolve,f');\r\n\r\n    // define the start block\r\n    Blockly.defineBlocksWithJsonArray([{\r\n        \"type\": Gamepad['BLOCKS']['START'],\r\n        \"message0\": \"Start\",\r\n        \"deletable_\": false,\r\n        \"lastDummyAlign0\": \"CENTRE\",\r\n        \"nextStatement\": null,\r\n        \"style\": \"hat_blocks\"\r\n    }]);\r\n}\r\n\r\n/* Gamepad init function */\r\nGamepad.init = function (options) {\r\n    if (!Blockly) throw new Error('Blockly library not included');\r\n    if (!Blockly.hasOwnProperty('JavaScript')) throw new Error('JavaScript generator library not included');\r\n\r\n    // options check\r\n    if (options === undefined) throw new Error('options must not be undefined');\r\n\r\n    // load the inputs\r\n    if (options.hasOwnProperty('inputs')) this['INPUTS'] = options.inputs;\r\n    // load the toolbox\r\n    if (options.hasOwnProperty('toolbox')) this['TOOLBOX'] = Gamepad.utils.xml2json(options.toolbox, \"\");\r\n    // load the context\r\n    if (options.hasOwnProperty('context')) this['CONTEXT'] = options.context;\r\n\r\n    // load the blocks\r\n    if (options.hasOwnProperty('blocks')) Gamepad.utils.blocks(options.blocks, \"\");\r\n    // wrap standar blocks\r\n    if (options.hasOwnProperty('wrap')) Gamepad.utils.wrap(options.wrap, \"\");\r\n}\r\n\r\n/* Gamepad BlocklyManager */\r\n// this class manage the workspace and the code generation\r\nGamepad.BlocklyManager = class {\r\n    constructor(options) {\r\n        options = options || {}\r\n\r\n        // if someone is changing the workspace\r\n        this.isCoding = false;\r\n        // if use the strat block\r\n        this.start = options.start === true;\r\n        // set custom highlight\r\n        this.customHighlight = options.customHighlight === true;\r\n        // set the workspace, default is Blockly.getMainWorkspace()\r\n        this.workspace = options.workspace || Blockly.getMainWorkspace();\r\n\r\n        this.workspace.addChangeListener((event) => {\r\n            if (event.type == Blockly.Events.BLOCK_MOVE) {\r\n                // update codinge state and remove block highlight\r\n                if (!this.isCoding) this.removeHighlight();\r\n                this.isCoding = true;\r\n            }\r\n        });\r\n\r\n        this.reset();\r\n    }\r\n\r\n    // get the code\r\n    code(times) {\r\n        // update coding state\r\n        this.isCoding = false;\r\n        // clear the workspace\r\n        if (this.start) this.clear();\r\n\r\n        // get the code\r\n        let code = Blockly.JavaScript.workspaceToCode(this.workspace);\r\n        code = Gamepad.utils.code(code, times);\r\n\r\n        return code;\r\n    }\r\n\r\n    // clear the workspace\r\n    clear() {\r\n        let blocks = this.workspace.getTopBlocks();\r\n        // remove all the blocks expect the start block and the functions\r\n        for (let block of blocks) {\r\n            if (!block.type.includes('procedures_def') && (!this.start || (block.type != Gamepad['BLOCKS']['START'])))\r\n                block.dispose(false);\r\n        }\r\n    }\r\n\r\n    // reset the workspace\r\n    reset() {\r\n        this.workspace.clear();\r\n        setTimeout(() => {\r\n            // clear the trashcan\r\n            if (this.workspace.trashcan) this.workspace.trashcan.clear();\r\n        });\r\n\r\n        // if start is enabled the block is generated\r\n        if (this.start) {\r\n            this.parentBlock = this.workspace.newBlock(Gamepad['BLOCKS']['START'], Gamepad['STATES']['STARTED']);\r\n            this.parentBlock.setDeletable(false);\r\n            this.parentBlock.startHat_ = true;\r\n            this.parentBlock.initSvg();\r\n            this.parentBlock.render();\r\n            this.parentBlock.setMovable(false);\r\n            this.parentBlock.moveBy(20, 20);\r\n        }\r\n\r\n        this.workspace.scrollX = 15;\r\n        this.workspace.scrollY = 15;\r\n\r\n        // avoid ctrl+z to restore the old workspace\r\n        this.workspace.undoStack_ = [];\r\n    }\r\n\r\n    // update the toolbox\r\n    setToolbox(options) {\r\n        if (!options) return;\r\n        // get the toolbox object\r\n        let toolbox = JSON.parse(Gamepad['TOOLBOX']);\r\n\r\n        // show some blocks\r\n        if ('blocks' in options) {\r\n            if (!Array.isArray(options.blocks)) throw new Error('options.blocks must be an array.');\r\n\r\n            // filter the json\r\n            Gamepad.utils.filter(toolbox.XML, options);\r\n\r\n            this.workspace.updateToolbox(Gamepad.utils.json2xml(toolbox));\r\n            // show all blocks\r\n        } else if ('all' in options) {\r\n            this.workspace.updateToolbox(Gamepad.utils.json2xml(toolbox));\r\n        }\r\n    }\r\n\r\n    // highlight a block\r\n    setHighlight(id) {\r\n        if (this.customHighlight) {\r\n            this.removeHighlight();\r\n            try {\r\n                document.querySelector(\"[data-id='\" + id + \"']\").classList.add('blocklySelected');\r\n            } catch (error) { }\r\n        } else {\r\n            this.workspace.highlightBlock(id);\r\n        }\r\n    }\r\n\r\n    // remove the highlight from all the blocks\r\n    removeHighlight() {\r\n        if (this.customHighlight) {\r\n            let blocks = document.getElementsByClassName(\"blocklySelected\");\r\n            for (let i = blocks.length; i > 0; i--) blocks[i - 1].classList.remove('blocklySelected');\r\n        } else {\r\n            this.workspace.highlightBlock();\r\n        }\r\n    }\r\n\r\n    // get the blocks number { total: 10, move_up: 2, ...}\r\n    getBlocksNumber() {\r\n        let blocks = this.workspace.getAllBlocks(),\r\n            result = {\r\n                total: 0\r\n            }\r\n\r\n        for (let block of blocks) {\r\n            if (result[block.type] == undefined) result[block.type] = 0;\r\n            result[block.type]++;\r\n            result.total++;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // save the workspace in the local storage\r\n    save(name) {\r\n        if (typeof (Storage) !== \"undefined\") {\r\n            let xml = Blockly.Xml.workspaceToDom(this.workspace);\r\n            localStorage.setItem(name, Blockly.Xml.domToText(xml));\r\n        }\r\n    }\r\n\r\n    // restore the workspace from the local storage\r\n    restore(name) {\r\n        if (typeof (Storage) !== \"undefined\") {\r\n            if (localStorage.getItem(name) != null) {\r\n                this.workspace.clear();\r\n                try {\r\n                    let xml = Blockly.Xml.textToDom(localStorage.getItem(name));\r\n                    Blockly.Xml.domToWorkspace(xml, this.workspace);\r\n                } catch (error) {\r\n                    this.reset()\r\n                }\r\n            }\r\n\r\n            if (this.workspace.trashcan)\r\n                this.workspace.trashcan.clear();\r\n\r\n            if (this.start) {\r\n                let blocks = this.workspace.getTopBlocks();\r\n\r\n                for (let block of blocks) {\r\n                    if (block.type == Gamepad['BLOCKS']['START']) return;\r\n                }\r\n\r\n                this.reset();\r\n            }\r\n        }\r\n    }\r\n\r\n    // resize the workspace\r\n    resize() {\r\n        Blockly.svgResize(this.workspace);\r\n    }\r\n}\r\n\r\n/* Gamepad History */\r\n// this class manage a simple history of events\r\nGamepad.History = class {\r\n    constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    // get the length\r\n    get length() {\r\n        return this.history.length;\r\n    }\r\n\r\n    // add an event\r\n    add(event, update) {\r\n        // remove the events after the current\r\n        this.history.splice(this.index + 1);\r\n        // push the event\r\n        this.history.push(event);\r\n        // update the index\r\n        if (update) this.index = this.length - 1;\r\n    }\r\n\r\n    // update the current element and return it\r\n    get next() {\r\n        if (this.index < this.length - 1)\r\n            return this.history[++this.index];\r\n    }\r\n\r\n    // update the current element and return it\r\n    // if the current is the first one it becomes undefined\r\n    get prior() {\r\n        if (this.index > -1)\r\n            return this.history[--this.index];\r\n    }\r\n\r\n    // get the current event\r\n    get current() {\r\n        if (this.index > -1) return this.history[this.index];\r\n    }\r\n\r\n    // reset\r\n    reset() {\r\n        this.index = -1;\r\n        this.history = [];\r\n    }\r\n}\r\n\r\n/* Gamepad Queue */\r\n// this class manage an asynchronous queue\r\nGamepad.Queue = class {\r\n    constructor() {\r\n        // requests\r\n        this.requests = [];\r\n        // if the queue is closed\r\n        this.closed = false;\r\n        // set the listener\r\n        this.setListener();\r\n    }\r\n\r\n    // set the listener, once a request is setted the listener is resolved\r\n    setListener() {\r\n        // set the listener\r\n        this.listener = new Promise((resolve, reject) => {\r\n            // once a request has been setted this method is called and the listener will manage the get function\r\n            this.setted = (options) => {\r\n                // if there's no options a request has been setted and can be returned by the get method\r\n                if (!options) return resolve();\r\n                // if the queue has been closed the get method will return undefined\r\n                if (options.close) return resolve(true);\r\n                // if the queue has been resetted throw the closed error\r\n                if (options.reset) return reject(Gamepad['ERRORS']['CLOSED']);\r\n\r\n                resolve();\r\n            }\r\n        });\r\n\r\n        // wrap it to avoid the console.error if it'll be rejected\r\n        this.listener.then(() => { }, () => { });\r\n    }\r\n\r\n    // reset the queue\r\n    reset() {\r\n        this.requests = [];\r\n        this.closed = false;\r\n\r\n        // resolve the listener with the reset event\r\n        this.setted({\r\n            reset: true\r\n        });\r\n        // set the listener\r\n        this.setListener();\r\n    }\r\n\r\n    // close the queue, get function will return undefined\r\n    close() {\r\n        this.closed = true;\r\n        // resolve the listener with the close event\r\n        this.setted({\r\n            close: true\r\n        });\r\n    }\r\n\r\n    // open the queue, get function will work normally\r\n    open() {\r\n        this.closed = false;\r\n    }\r\n\r\n    // get the current request\r\n    //\r\n    // if there's no request the set event is awaited\r\n    //\r\n    // if there are more calls to this method when the request is not setted \r\n    // all the callers will receive the same result\r\n    get() {\r\n        // if the queue is closed return undefined\r\n        if (this.closed) return Promise.resolve();\r\n\r\n        // set the result and return it\r\n        return this.listener.then(\r\n            closed => {\r\n                // if the queue is closed return undefined\r\n                if (closed) {\r\n                    this.setListener();\r\n                    return;\r\n                }\r\n                // resolve the request\r\n                let request = this.requests.shift();\r\n\r\n                // set the listener\r\n                this.setListener();\r\n                // if there's at least one request resolve the listener\r\n                if (this.requests.length != 0) this.setted();\r\n\r\n                return request;\r\n            }\r\n        );\r\n    }\r\n\r\n    // set the request\r\n    set(request) {\r\n        this.requests.push(request);\r\n        // if there's al least one request resolve the listener\r\n        this.setted();\r\n    }\r\n}\r\n\r\n/* Gamepad Asynchronizer */\r\n// this class generate .async instances of a given target\r\nGamepad.Asynchronizer = class {\r\n    constructor(sync, onRun, onReset) {\r\n        this.sync = sync || {}\r\n        this.async = {}\r\n        this.onRun = onRun || function () { }\r\n        this.onReset = onReset || function () { }\r\n\r\n        // set the state\r\n        this.state = Gamepad.utils.promiseWrapper();\r\n        this.state.resolve();\r\n\r\n        // the proxy handler\r\n        this.handler = {\r\n            // set the getter\r\n            get: function (obj, prop) {\r\n                // if has been resetted\r\n                if (Object.getOwnPropertySymbols(obj).includes(Gamepad['SYMBOL']))\r\n                    // throw Gamepad['ERRORS']['CLOSED']\r\n                    throw Gamepad['ERRORS']['CLOSED'];\r\n                else\r\n                    // normal getter\r\n                    return obj[prop];\r\n            }\r\n        }\r\n    }\r\n\r\n    // kill the .async instance\r\n    reset() {\r\n        // if the asynchronizer is resetting\r\n        if (this.state.isPending()) return;\r\n\r\n        // set the state\r\n        this.state = Gamepad.utils.promiseWrapper();\r\n\r\n        // set the symbol to check if the async has been resetted\r\n        this.async[Gamepad['SYMBOL']] = true;\r\n\r\n        // call the onReset function\r\n        return this.onReset.apply(this.sync, [...arguments]);\r\n    }\r\n\r\n    // generate the .async instance\r\n    run() {\r\n        // if the asynchronizer is running\r\n        if (this.state.isFulfilled()) return;\r\n\r\n        // set the .async copying the properties\r\n        this.async = new Proxy(this.sync && this.sync.prototype\r\n            ? new this.sync()\r\n            : Object.defineProperties(Object.assign({}, this.sync), Object.getOwnPropertyDescriptors(this.sync)), this.handler);\r\n\r\n        // call the onRun\r\n        let result = this.onRun.apply(this.async, [...arguments]);\r\n\r\n        // if the result is a Promise\r\n        if (result instanceof Promise) {\r\n            return result.then(result => {\r\n                // resolve the state\r\n                this.state.resolve();\r\n                // return the result\r\n                return result;\r\n            });\r\n        } else {\r\n            // resolve the listener\r\n            this.state.resolve();\r\n            // return the result\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\n/* Gamepad Worker */\r\n// The worker manage the request from the blocks\r\nGamepad.Worker = function () {\r\n    const asynchronizer = new Gamepad.Asynchronizer(\r\n        {\r\n            // history for the old requests\r\n            history: new Gamepad.History(),\r\n            // queue for forward/backward requests\r\n            queue: new Gamepad.Queue(),\r\n            // queue for blocks's requests\r\n            requests: new Gamepad.Queue(),\r\n            // debugger\r\n            debugger: {\r\n                // id of the block used as breakpoint\r\n                id: null,\r\n                // promise resolved on breakpoint reached\r\n                promise: Gamepad.utils.promiseWrapper()\r\n            },\r\n            // if the worker is running\r\n            isRunning: false,\r\n            // running direction\r\n            back: false,\r\n            // create a forward/backward request\r\n            go: function (back) {\r\n                return new Promise(resolve => {\r\n                    this.queue.set({\r\n                        back: back === true,\r\n                        resolve\r\n                    });\r\n                })\r\n            },\r\n            // free the queue\r\n            freeQueue: function () {\r\n                // get the requests\r\n                this.queue.close();\r\n                const requests = this.queue.requests;\r\n                this.queue.reset();\r\n                // resolve each request\r\n                requests.forEach(request => request && request.resolve && request.resolve(false));\r\n            },\r\n            // start the worker\r\n            start: function (back) {\r\n                this.back = back === true;\r\n                // if it is running\r\n                if (this.isRunning) return;\r\n                // update running state\r\n                this.isRunning = true;\r\n                // free the queue getter (.get())\r\n                this.queue.close();\r\n                this.queue.open();\r\n            },\r\n            // stop the worker\r\n            stop: function () {\r\n                this.isRunning = false;\r\n                this.removeBreakpoint();\r\n            },\r\n            // set a request from the blocks\r\n            setRequest: function (request) {\r\n                return new Promise((resolve, reject) => {\r\n                    this.requests.set({\r\n                        request,\r\n                        resolve,\r\n                        reject\r\n                    });\r\n                });\r\n            },\r\n            // close the worker, requests are not passed anymore\r\n            close: function () {\r\n                this.requests.close();\r\n            },\r\n            // open the worker\r\n            open: function () {\r\n                this.requests.open();\r\n            },\r\n            // set as breakpoint the request with the passed id\r\n            setBreakpoint: function (id) {\r\n                if (id === undefined) return;\r\n                if (id === null && this.debugger.id === null) return;\r\n                // end old debugger\r\n                if (this.debugger.promise.isPending())\r\n                    this.debugger.promise.resolve(false);\r\n                // set the debugger\r\n                this.debugger.id = id;\r\n                this.debugger.promise = Gamepad.utils.promiseWrapper();\r\n\r\n                // don't return the wrapped promise\r\n                return this.debugger.promise.then(result => result);\r\n            },\r\n            // remove the current breakpoint\r\n            removeBreakpoint: function () {\r\n                this.setBreakpoint(null);\r\n            }\r\n        },\r\n        function () {\r\n            // start the flow or requests\r\n            const start = async () => {\r\n                try {\r\n                    while (true) {\r\n                        // if is running load a forward request\r\n                        // else get from the queue\r\n                        let request = this.isRunning\r\n                            ? { back: this.back }\r\n                            : await this.queue.get() || { p: 'p', back: this.back }\r\n\r\n                        // backward or forward\r\n                        request.back\r\n                            ? await backward()\r\n                            : await forward();\r\n\r\n                        // resolve the forward/backward request\r\n                        if (request.resolve) request.resolve(true);\r\n                    }\r\n                } catch (error) {\r\n                    // don't throw the error if the worker has been resetted\r\n                    Gamepad.utils.errorHandler(error);\r\n                }\r\n            }\r\n\r\n            // backward manager\r\n            const backward = async () => {\r\n                // get the request from the history\r\n                let request = this.history.current;\r\n                // load prior request\r\n                this.history.prior;\r\n\r\n                // the first history item is undefined\r\n                if (request !== undefined) {\r\n                    await this.manage(request, true, true);\r\n                    // debug check\r\n                    debug(request.id);\r\n                } else {\r\n                    this.stop();\r\n                }\r\n            }\r\n\r\n            // forward manager\r\n            const forward = async () => {\r\n                let request, result;\r\n\r\n                // if there's a request in the history\r\n                if ((request = this.history.next) !== undefined) {\r\n                    await this.manage(request, false, true);\r\n                    // debug check\r\n                    debug(request.id);\r\n                    return;\r\n                }\r\n\r\n                // get the request from the queue\r\n                request = await this.requests.get();\r\n\r\n                // if the worker has been closed the request will be undefined\r\n                if (request === undefined) {\r\n                    this.stop();\r\n                    return;\r\n                }\r\n\r\n                if (this.history.current) {\r\n                    // it's possible that a block pass the 'FINISHED' state\r\n                    // when it's passed the upcoming requests need to be killed until the next 'STARTED' state\r\n                    if (this.history.current.method == Gamepad['STATES']['FINISHED']) {\r\n                        if (request.request.method != Gamepad['STATES']['STARTED'] && request.request.method != Gamepad['STATES']['COMPLETED']) {\r\n                            // throwing Gamepad['STATES']['FINISHED'] will kill all the requests until the next 'STARTED' state \r\n                            request.reject(Gamepad['ERRORS']['FINISHED']);\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    // it's possible that a block pass the 'COMPLETED' state\r\n                    // when it's passed all the requests need to be killed\r\n                    if (this.history.current.method == Gamepad['STATES']['COMPLETED']) {\r\n                        // throwing Gamepad['STATES']['COMPLETED'] will kill all the requests\r\n                        request.reject(Gamepad['ERRORS']['COMPLETED']);\r\n                        this.stop();\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                // manage the request\r\n                result = await this.manage(request.request, false, false);\r\n                if (result === undefined) result = {}\r\n\r\n                // add the request to the history\r\n                this.history.add(request.request, true);\r\n\r\n                // debug check\r\n                debug(request.request.id);\r\n\r\n                if (result.finished) {\r\n                    // if result.finished reject the 'FINISHED' error\r\n                    // all the upcoming requests are killed until the next 'STARTED' state\r\n                    // the current request is now the 'FINISHED' one but it is not passed to the game\r\n                    this.history.add(\r\n                        Gamepad.utils.build(Gamepad['STATES']['FINISHED'], [], Gamepad['STATES']['FINISHED'], { generated: true }),\r\n                        true\r\n                    );\r\n                    // load the request\r\n                    this.history.next;\r\n\r\n                    // debug check because that request is loaded but it is not passed to the game\r\n                    debug(Gamepad['STATES']['FINISHED']);\r\n\r\n                    // throw the error\r\n                    request.reject(Gamepad['ERRORS']['FINISHED']);\r\n\r\n                } else if (result.completed) {\r\n                    // if result.finished reject the 'COMPLETED' error\r\n                    // all the requests are killed\r\n                    // the current request is now the 'COMPLETED' one but it is not passed to the game\r\n                    this.history.add(\r\n                        Gamepad.utils.build(Gamepad['STATES']['COMPLETED'], [], Gamepad['STATES']['COMPLETED'], { generated: true }),\r\n                        true\r\n                    );\r\n                    // load the request\r\n                    this.history.next;\r\n\r\n                    // debug check because that request is loaded but it is not passed to the game\r\n                    debug(Gamepad['STATES']['COMPLETED']);\r\n\r\n                    // throw the error\r\n                    request.reject(Gamepad['ERRORS']['COMPLETED']);\r\n\r\n                    // close the worker\r\n                    this.close();\r\n                } else {\r\n                    request.resolve(result.return);\r\n                }\r\n            }\r\n\r\n            // debug check\r\n            const debug = (id) => {\r\n                if (this.debugger.id !== null && this.debugger.id == id) {\r\n                    this.debugger.promise.resolve(true);\r\n                    this.freeQueue();\r\n                    this.stop();\r\n                }\r\n            }\r\n\r\n            start();\r\n        },\r\n        function () {\r\n            // free the queue\r\n            this.freeQueue();\r\n            // reset\r\n            this.queue.reset();\r\n            this.requests.reset();\r\n            this.history.reset();\r\n            // remove the breakpoint\r\n            this.removeBreakpoint();\r\n        });\r\n\r\n    // methods\r\n    Object.assign(this, {\r\n        // reset\r\n        reset: function () {\r\n            asynchronizer.reset();\r\n            asynchronizer.run();\r\n        },\r\n        // request manager\r\n        onRequest: function (thisArg, method) {\r\n            asynchronizer.sync.manage = function (request, back, old) {\r\n                return method.apply(thisArg, [request, back, old]);\r\n            }\r\n        },\r\n        // return the current async\r\n        // the .async will be used by the code generators\r\n        getInstance: function () {\r\n            return asynchronizer.async;\r\n        }\r\n    });\r\n\r\n    // link the async methods\r\n    for (const method of [\r\n        'go',\r\n        'setRequest',\r\n        'start',\r\n        'stop',\r\n        'close',\r\n        'freeQueue',\r\n        'setBreakpoint',\r\n        'removeBreakpoint'\r\n    ]) {\r\n        this[method] = function () {\r\n            let ac = asynchronizer.async;\r\n            try {\r\n                return ac[method].apply(ac, [...arguments]);\r\n            } catch (error) {\r\n                Gamepad.utils.errorHandler(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    // link the async properties\r\n    for (const property of [\r\n        'isRunning',\r\n        'back'\r\n    ]) {\r\n        Object.defineProperty(this, property, {\r\n            get: function () {\r\n                try { return asynchronizer.async[property]; }\r\n                catch (error) { }\r\n            }\r\n        });\r\n    }\r\n\r\n    this.reset();\r\n}\r\n\r\n/* eval function */\r\nGamepad.evalContext = function (code, worker) {\r\n    try {\r\n        let CONTEXT = Gamepad['CONTEXT'];\r\n        eval(code);\r\n    } catch (err) {\r\n        console.error('There\\'s an error in the code: \\n', code);\r\n        console.error(err);\r\n    }\r\n}\r\n\r\n/* Gamepad observer */\r\n// the observer instances are used to manage the magicJson options\r\nGamepad.observer = {\r\n    // insert event\r\n    INSERT: 'insert',\r\n    // update event\r\n    UPDATE: 'update',\r\n    // delete event\r\n    DELETE: 'delete',\r\n    // pop event\r\n    POP: 'pop',\r\n    // push event\r\n    PUSH: 'push',\r\n    // shift event\r\n    SHIFT: 'shift',\r\n    // unshift event\r\n    UNSHIFT: 'unshift',\r\n    // reverse event\r\n    REVERSE: 'reverse',\r\n    // non observable object\r\n    nonObservables: {\r\n        Date: true,\r\n        Blob: true,\r\n        Number: true,\r\n        String: true,\r\n        Boolean: true,\r\n        Error: true,\r\n        SyntaxError: true,\r\n        TypeError: true,\r\n        URIError: true,\r\n        Function: true,\r\n        Promise: true,\r\n        RegExp: true\r\n    },\r\n    // observable definition\r\n    observableDefinition: {\r\n        // reverse\r\n        revoke: {\r\n            value: function () {\r\n                this[Gamepad['SYMBOL']].revoke();\r\n            }\r\n        },\r\n        // observe changes\r\n        observe: {\r\n            value: function (observer, options) {\r\n                let systemObserver = this[Gamepad['SYMBOL']],\r\n                    observers = systemObserver.observers;\r\n\r\n                if (typeof observer !== 'function') {\r\n                    throw new Error('observer parameter MUST be a function');\r\n                }\r\n\r\n                if (!observers.has(observer)) {\r\n                    observers.set(observer, Object.assign({}, options));\r\n                }\r\n            }\r\n        },\r\n        // unobserve\r\n        unobserve: {\r\n            value: function () {\r\n                let systemObserver = this[Gamepad['SYMBOL']],\r\n                    observers = systemObserver.observers,\r\n                    l;\r\n                if (observers.size) {\r\n                    l = arguments.length;\r\n                    if (l) {\r\n                        while (l--) {\r\n                            observers.delete(arguments[l]);\r\n                        }\r\n                    } else {\r\n                        observers.clear();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    },\r\n    // load the array\r\n    prepareArray: function (source, observer) {\r\n        let l = source.length,\r\n            item;\r\n        let target = new Array(source.length);\r\n        // bind the observer\r\n        target[Gamepad['SYMBOL']] = observer;\r\n        // prepare the children\r\n        while (l--) {\r\n            item = source[l];\r\n            if (item && typeof item === 'object' && !Gamepad.observer.nonObservables.hasOwnProperty(item.constructor.name)) {\r\n                target[l] = Array.isArray(item) ?\r\n                    new Gamepad.ArrayObserver({\r\n                        target: item,\r\n                        ownKey: l,\r\n                        parent: observer\r\n                    }).proxy :\r\n                    new Gamepad.ObjectObserver({\r\n                        target: item,\r\n                        ownKey: l,\r\n                        parent: observer\r\n                    }).proxy;\r\n            } else {\r\n                target[l] = item;\r\n            }\r\n        }\r\n        return target;\r\n    },\r\n    // load the object\r\n    prepareObject: function (source, observer) {\r\n        let keys = Object.keys(source),\r\n            l = keys.length,\r\n            key, item;\r\n        let target = {\r\n            // bind the observer\r\n            [Gamepad['SYMBOL']]: observer\r\n        }\r\n        // prepare the children\r\n        while (l--) {\r\n            key = keys[l];\r\n            item = source[key];\r\n            if (item && typeof item === 'object' && !Gamepad.observer.nonObservables.hasOwnProperty(item.constructor.name)) {\r\n                target[key] = Array.isArray(item) ?\r\n                    new Gamepad.ArrayObserver({\r\n                        target: item,\r\n                        ownKey: key,\r\n                        parent: observer\r\n                    }).proxy :\r\n                    new Gamepad.ObjectObserver({\r\n                        target: item,\r\n                        ownKey: key,\r\n                        parent: observer\r\n                    }).proxy;\r\n            } else {\r\n                target[key] = item;\r\n            }\r\n        }\r\n        return target;\r\n    },\r\n    // call the observers\r\n    callObservers: function (observers, changes) {\r\n        for (let target of observers.keys()) {\r\n            try {\r\n                let relevantChanges = changes;\r\n                target(relevantChanges);\r\n            } catch (e) {\r\n                console.error('failed to deliver changes to listener ' + target, e);\r\n            }\r\n        }\r\n    },\r\n    // get ancestor info\r\n    getAncestorInfo: function (self) {\r\n        let tmp = [],\r\n            result, l1 = 0,\r\n            l2 = 0;\r\n\r\n        // if the object is revoked return undefined\r\n        if (self.isRevoked) {\r\n            return;\r\n        }\r\n        // find the first parent\r\n        while (self.parent) {\r\n            tmp[l1++] = self.ownKey;\r\n            self = self.parent;\r\n            if (self.isRevoked) {\r\n                return;\r\n            }\r\n        }\r\n        result = new Array(l1);\r\n        while (l1--) result[l2++] = tmp[l1];\r\n        return {\r\n            observers: self.observers,\r\n            path: result\r\n        }\r\n    },\r\n    // get the last property \r\n    // (target, ['a', 'b', 'c']) => { target: target.a.b, key: 'c'}\r\n    getLastProp: function (target, path) {\r\n        for (let i = 0; i < path.length - 1; i++)\r\n            target = target[path[i]];\r\n\r\n        return {\r\n            key: path[path.length - 1],\r\n            target\r\n        }\r\n    },\r\n    // load single change\r\n    loadChange: function (observer, change) {\r\n        let { target, key } = Gamepad.observer.getLastProp(observer, change.path);\r\n        // objects and arrays need different changes with the INSERT and DELETE events\r\n        if (Array.isArray(target)) {\r\n            if (change.type == Gamepad.observer.INSERT) {\r\n                // if the key isn't a number the if is false and it will set the value correctly\r\n                if (target.length > key)\r\n                    target.splice(key, 0, change.value);\r\n                else\r\n                    target[key] = change.value;\r\n            }\r\n            if (change.type == Gamepad.observer.DELETE) target.splice(key, 1);\r\n        } else {\r\n            if (change.type == Gamepad.observer.INSERT) target[key] = change.value;\r\n            if (change.type == Gamepad.observer.DELETE) delete target[key];\r\n        }\r\n\r\n        // array only changes\r\n        if (change.type == Gamepad.observer.PUSH) target[key].push.apply(target, change.value);\r\n        if (change.type == Gamepad.observer.POP) target[key].pop();\r\n        if (change.type == Gamepad.observer.UNSHIFT) target[key].unshift.apply(target, change.value);\r\n        if (change.type == Gamepad.observer.SHIFT) target[key].shift();\r\n        if (change.type == Gamepad.observer.REVERSE) target[key].reverse();\r\n        // common changes\r\n        if (change.type == Gamepad.observer.UPDATE) target[key] = change.value;\r\n    },\r\n    // unload single change\r\n    unloadChange: function (observer, change) {\r\n        let { target, key } = Gamepad.observer.getLastProp(observer, change.path);\r\n        // objects and arrays need different changes with the INSERT and DELETE events\r\n        if (Array.isArray(target)) {\r\n            if (change.type == Gamepad.observer.INSERT) {\r\n                // if the key isn't a number the if is false and it will set the value correctly\r\n                if (target.length > key)\r\n                    target.splice(key, 1);\r\n                else\r\n                    delete target[key];\r\n            }\r\n            if (change.type == Gamepad.observer.DELETE) target.splice(key, 0, change.oldValue);\r\n        } else {\r\n            if (change.type == Gamepad.observer.INSERT) delete target[key];\r\n            if (change.type == Gamepad.observer.DELETE) target[key] = change.oldValue;\r\n        }\r\n\r\n        // array only changes\r\n        if (change.type == Gamepad.observer.PUSH) {\r\n            for (let i = 0; i < change.value.length; i++) target[key].pop();\r\n        }\r\n        if (change.type == Gamepad.observer.POP) target[key].push(change.oldValue);\r\n        if (change.type == Gamepad.observer.UNSHIFT) {\r\n            for (let i = 0; i < change.value.length; i++) target[key].shift();\r\n        }\r\n        if (change.type == Gamepad.observer.SHIFT) target[key].unshift(change.oldValue);\r\n        if (change.type == Gamepad.observer.REVERSE) target[key].reverse();\r\n        // common changes\r\n        if (change.type == Gamepad.observer.UPDATE) target[key] = change.oldValue;\r\n    },\r\n    // observe a json\r\n    observeJson: function (target) {\r\n        if (target && typeof target === 'object' && !Gamepad.observer.nonObservables.hasOwnProperty(target.constructor.name) && !\r\n            ('observe' in target) && !('unobserve' in target) && !('revoke' in target)) {\r\n            let observed = Array.isArray(target) ?\r\n                new Gamepad.ArrayObserver({\r\n                    target: target,\r\n                    ownKey: null,\r\n                    parent: null\r\n                }) :\r\n                new Gamepad.ObjectObserver({\r\n                    target: target,\r\n                    ownKey: null,\r\n                    parent: null\r\n                });\r\n            return observed.proxy;\r\n        } else {\r\n            if (!target || typeof target !== 'object') {\r\n                throw new Error('observable MAY ONLY be created from non-null object only');\r\n            } else if ('observe' in target || 'unobserve' in target || 'revoke' in target) {\r\n                throw new Error(\r\n                    'target object MUST NOT have nor own neither inherited properties from the following list: \"observe\", \"unobserve\", \"revoke\"'\r\n                );\r\n            } else if (Gamepad.observer.nonObservables.hasOwnProperty(target.constructor.name)) {\r\n                throw new Error(target + ' found to be one of non-observable object types: ' + Gamepad.observer.nonObservables);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/* Observer class */\r\n// the observer class generate a Proxy that wrap a target object\r\n// It's possible to bind a listener to the changes of the proxy\r\nGamepad.Observer = class {\r\n    constructor(properties, cloningFunction) {\r\n        // prepare the source\r\n        let source = properties.target,\r\n            targetClone = cloningFunction(source, this);\r\n        // bind to parents\r\n        if (properties.parent === null) {\r\n            this.isRevoked = false;\r\n            Object.defineProperty(this, 'observers', {\r\n                value: new Map()\r\n            });\r\n            Object.defineProperties(targetClone, Gamepad.observer.observableDefinition);\r\n        } else {\r\n            this.parent = properties.parent;\r\n            this.ownKey = properties.ownKey;\r\n        }\r\n        // set the proxy\r\n        this.revokable = Proxy.revocable(targetClone, this);\r\n        this.proxy = this.revokable.proxy;\r\n        this.target = targetClone;\r\n    }\r\n\r\n    // set trap\r\n    set(target, key, value) {\r\n        // if the proxy is revoked it will work as a normal object\r\n        if (this.isRevoked) {\r\n            target[key] = value;\r\n            return true;\r\n        }\r\n\r\n        let newValue, oldValue = target[key],\r\n            ad, changes;\r\n\r\n        // prepare the value\r\n        if (value && typeof value === 'object' && !Gamepad.observer.nonObservables.hasOwnProperty(value.constructor.name)) {\r\n            newValue = Array.isArray(value) ?\r\n                new Gamepad.ArrayObserver({\r\n                    target: value,\r\n                    ownKey: key,\r\n                    parent: this\r\n                }).proxy :\r\n                new Gamepad.ObjectObserver({\r\n                    target: value,\r\n                    ownKey: key,\r\n                    parent: this\r\n                }).proxy;\r\n        } else {\r\n            newValue = value;\r\n        }\r\n        target[key] = newValue;\r\n\r\n        // revoke the old object\r\n        if (oldValue && typeof oldValue === 'object') {\r\n            let tmpObserved = oldValue[Gamepad['SYMBOL']];\r\n            if (tmpObserved) {\r\n                oldValue = tmpObserved.revoke();\r\n            }\r\n        }\r\n\r\n        // push changes\r\n        ad = Gamepad.observer.getAncestorInfo(this);\r\n        if (!ad) return;\r\n        if (ad.observers.size) {\r\n            ad.path.push(key);\r\n            changes = typeof oldValue === 'undefined' ? [{\r\n                type: Gamepad.observer.INSERT,\r\n                path: ad.path,\r\n                value: newValue,\r\n                object: this.proxy\r\n            }] : [{\r\n                type: Gamepad.observer.UPDATE,\r\n                path: ad.path,\r\n                value: newValue,\r\n                oldValue: oldValue,\r\n                object: this.proxy\r\n            }];\r\n            Gamepad.observer.callObservers(ad.observers, changes);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // delete trap\r\n    deleteProperty(target, key) {\r\n        let oldValue = target[key],\r\n            ad, changes;\r\n\r\n        if (delete target[key]) {\r\n            // revoke the old object\r\n            if (oldValue && typeof oldValue === 'object') {\r\n                let tmpObserved = oldValue[Gamepad['SYMBOL']];\r\n                if (tmpObserved) {\r\n                    oldValue = tmpObserved.revoke();\r\n                }\r\n            }\r\n\r\n            // push changes\r\n            ad = Gamepad.observer.getAncestorInfo(this);\r\n            if (!ad) return;\r\n            if (ad.observers.size) {\r\n                ad.path.push(key);\r\n                changes = [{\r\n                    type: Gamepad.observer.DELETE,\r\n                    path: ad.path,\r\n                    oldValue: oldValue,\r\n                    object: this.proxy\r\n                }];\r\n                Gamepad.observer.callObservers(ad.observers, changes);\r\n            }\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n/* Array observer class */\r\n// observer for arrays\r\nGamepad.ArrayObserver = class extends Gamepad.Observer {\r\n    constructor(properties) {\r\n        super(properties, Gamepad.observer.prepareArray);\r\n    }\r\n\r\n    // revoke the observer, now it will work as a normal object\r\n    revoke() {\r\n        // set isRevoked prop\r\n        this.isRevoked = true;\r\n\r\n        let target = this.target,\r\n            l = target.length,\r\n            item;\r\n        // revoke children\r\n        while (l--) {\r\n            item = target[l];\r\n            // send revoke event to all sons\r\n            if (item && typeof item === 'object') {\r\n                let tmpObserved = item[Gamepad['SYMBOL']];\r\n                if (tmpObserved) {\r\n                    target[l] = tmpObserved.revoke();\r\n                }\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n    // get trap\r\n    get(target, key) {\r\n        // array methods\r\n        const proxiedArrayMethods = {\r\n            pop: function proxiedPop(target, observed) {\r\n                if (target.length == 0) return;\r\n                let popResult;\r\n                popResult = target.pop();\r\n                if (popResult && typeof popResult === 'object') {\r\n                    let tmpObserved = popResult[Gamepad['SYMBOL']];\r\n                    if (tmpObserved) {\r\n                        popResult = tmpObserved.revoke();\r\n                    }\r\n                }\r\n\r\n                let ad = Gamepad.observer.getAncestorInfo(observed);\r\n                if (!ad) return;\r\n                if (ad.observers.size) {\r\n                    Gamepad.observer.callObservers(ad.observers, [{\r\n                        type: Gamepad.observer.POP,\r\n                        path: ad.path,\r\n                        oldValue: popResult,\r\n                        object: observed.proxy\r\n                    }]);\r\n                }\r\n                return popResult;\r\n            },\r\n            push: function proxiedPush(target, observed) {\r\n                let i, l = arguments.length - 2,\r\n                    item, pushContent = new Array(l),\r\n                    pushResult, changes,\r\n                    initialLength, ad = Gamepad.observer.getAncestorInfo(observed);\r\n                initialLength = target.length;\r\n\r\n                for (i = 0; i < l; i++) {\r\n                    item = arguments[i + 2];\r\n                    if (item && typeof item === 'object' && !Gamepad.observer.nonObservables.hasOwnProperty(item\r\n                        .constructor.name)) {\r\n                        item = Array.isArray(item) ?\r\n                            new Gamepad.ArrayObserver({\r\n                                target: item,\r\n                                ownKey: initialLength + i,\r\n                                parent: observed\r\n                            }).proxy :\r\n                            new Gamepad.ObjectObserver({\r\n                                target: item,\r\n                                ownKey: initialLength + i,\r\n                                parent: observed\r\n                            }).proxy;\r\n                    }\r\n                    pushContent[i] = item;\r\n                }\r\n                pushResult = Reflect.apply(target.push, target, pushContent);\r\n\r\n                if (!ad) return;\r\n                if (ad.observers.size) {\r\n                    changes = [{\r\n                        type: Gamepad.observer.PUSH,\r\n                        path: ad.path,\r\n                        value: pushContent,\r\n                        object: observed.proxy\r\n                    }]\r\n                    Gamepad.observer.callObservers(ad.observers, changes);\r\n                }\r\n                return pushResult;\r\n            },\r\n            shift: function proxiedShift(target, observed) {\r\n                if (target.length == 0) return;\r\n                let shiftResult, i, l, item, ad, changes;\r\n\r\n                shiftResult = target.shift();\r\n                if (shiftResult && typeof shiftResult === 'object') {\r\n                    let tmpObserved = shiftResult[Gamepad['SYMBOL']];\r\n                    if (tmpObserved) {\r\n                        shiftResult = tmpObserved.revoke();\r\n                    }\r\n                }\r\n\r\n                for (i = 0, l = target.length; i < l; i++) {\r\n                    item = target[i];\r\n                    if (item && typeof item === 'object') {\r\n                        let tmpObserved = item[Gamepad['SYMBOL']];\r\n                        if (tmpObserved) {\r\n                            tmpObserved.ownKey = i;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                ad = Gamepad.observer.getAncestorInfo(observed);\r\n                if (!ad) return;\r\n                if (ad.observers.size) {\r\n                    changes = [{\r\n                        type: Gamepad.observer.SHIFT,\r\n                        path: ad.path,\r\n                        oldValue: shiftResult,\r\n                        object: observed.proxy\r\n                    }];\r\n                    Gamepad.observer.callObservers(ad.observers, changes);\r\n                }\r\n                return shiftResult;\r\n            },\r\n            unshift: function proxiedUnshift(target, observed) {\r\n                let unshiftContent, unshiftResult, ad, changes;\r\n                unshiftContent = Array.from(arguments);\r\n                unshiftContent.splice(0, 2);\r\n                unshiftContent.forEach((item, index) => {\r\n                    if (item && typeof item === 'object' && !Gamepad.observer.nonObservables.hasOwnProperty(item\r\n                        .constructor.name)) {\r\n                        unshiftContent[index] = Array.isArray(item) ?\r\n                            new Gamepad.ArrayObserver({\r\n                                target: item,\r\n                                ownKey: index,\r\n                                parent: observed\r\n                            }).proxy :\r\n                            new Gamepad.ObjectObserver({\r\n                                target: item,\r\n                                ownKey: index,\r\n                                parent: observed\r\n                            }).proxy;\r\n                    }\r\n                });\r\n                unshiftResult = Reflect.apply(target.unshift, target, unshiftContent);\r\n                for (let i = 0, l = target.length, item; i < l; i++) {\r\n                    item = target[i];\r\n                    if (item && typeof item === 'object') {\r\n                        let tmpObserved = item[Gamepad['SYMBOL']];\r\n                        if (tmpObserved) {\r\n                            tmpObserved.ownKey = i;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                ad = Gamepad.observer.getAncestorInfo(observed);\r\n                if (!ad) return;\r\n                if (ad.observers.size) {\r\n                    changes = [{\r\n                        type: Gamepad.observer.UNSHIFT,\r\n                        path: ad.path,\r\n                        value: unshiftContent,\r\n                        object: observed.proxy\r\n                    }]\r\n\r\n                    Gamepad.observer.callObservers(ad.observers, changes);\r\n                }\r\n                return unshiftResult;\r\n            },\r\n            reverse: function proxiedReverse(target, observed) {\r\n                let i, l, item, ad, changes;\r\n                target.reverse();\r\n                for (i = 0, l = target.length; i < l; i++) {\r\n                    item = target[i];\r\n                    if (item && typeof item === 'object') {\r\n                        let tmpObserved = item[Gamepad['SYMBOL']];\r\n                        if (tmpObserved) {\r\n                            tmpObserved.ownKey = i;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                ad = Gamepad.observer.getAncestorInfo(observed);\r\n                if (!ad) return;\r\n                if (ad.observers.size) {\r\n                    changes = [{\r\n                        type: Gamepad.observer.REVERSE,\r\n                        path: ad.path,\r\n                        object: observed.proxy\r\n                    }];\r\n                    Gamepad.observer.callObservers(ad.observers, changes);\r\n                }\r\n                return observed.proxy;\r\n            },\r\n            sort: function proxiedSort(target, observed, comparator) {\r\n                let i, l, item, ad, changes, oldValue = target.slice(0);\r\n                target.sort(comparator);\r\n                for (i = 0, l = target.length; i < l; i++) {\r\n                    item = target[i];\r\n                    if (item && typeof item === 'object') {\r\n                        let tmpObserved = item[Gamepad['SYMBOL']];\r\n                        if (tmpObserved) {\r\n                            tmpObserved.ownKey = i;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                ad = Gamepad.observer.getAncestorInfo(observed);\r\n                if (!ad) return;\r\n                if (ad.observers.size) {\r\n                    changes = [{\r\n                        type: Gamepad.observer.UPDATE,\r\n                        value: target,\r\n                        oldValue,\r\n                        path: ad.path,\r\n                        object: observed.proxy\r\n                    }];\r\n                    Gamepad.observer.callObservers(ad.observers, changes);\r\n                }\r\n                return observed.proxy;\r\n            },\r\n            fill: function proxiedFill(target, observed) {\r\n                let ad = Gamepad.observer.getAncestorInfo(observed),\r\n                    normArgs, argLen,\r\n                    start, end, changes = [],\r\n                    prev, tarLen = target.length,\r\n                    path;\r\n                normArgs = Array.from(arguments);\r\n                normArgs.splice(0, 2);\r\n                argLen = normArgs.length;\r\n                start = argLen < 2 ? 0 : (normArgs[1] < 0 ? tarLen + normArgs[1] : normArgs[1]);\r\n                end = argLen < 3 ? tarLen : (normArgs[2] < 0 ? tarLen + normArgs[2] : normArgs[2]);\r\n                prev = target.slice(0);\r\n                Reflect.apply(target.fill, target, normArgs);\r\n\r\n                for (let i = start, item, tmpTarget; i < end; i++) {\r\n                    item = target[i];\r\n                    if (item && typeof item === 'object' && !Gamepad.observer.nonObservables.hasOwnProperty(item\r\n                        .constructor.name)) {\r\n                        target[i] = Array.isArray(item) ?\r\n                            new Gamepad.ArrayObserver({\r\n                                target: item,\r\n                                ownKey: i,\r\n                                parent: observed\r\n                            }).proxy :\r\n                            new Gamepad.ObjectObserver({\r\n                                target: item,\r\n                                ownKey: i,\r\n                                parent: observed\r\n                            }).proxy;\r\n                    }\r\n                    if (prev.hasOwnProperty(i)) {\r\n                        tmpTarget = prev[i];\r\n                        if (tmpTarget && typeof tmpTarget === 'object') {\r\n                            let tmpObserved = tmpTarget[Gamepad['SYMBOL']];\r\n                            if (tmpObserved) {\r\n                                tmpTarget = tmpObserved.revoke();\r\n                            }\r\n                        }\r\n\r\n                        path = ad.path.slice(0);\r\n                        path.push(i);\r\n                        changes.push({\r\n                            type: Gamepad.observer.UPDATE,\r\n                            path: path,\r\n                            value: target[i],\r\n                            oldValue: tmpTarget,\r\n                            object: observed.proxy\r\n                        });\r\n                    } else {\r\n                        path = ad.path.slice(0);\r\n                        path.push(i);\r\n                        changes.push({\r\n                            type: Gamepad.observer.INSERT,\r\n                            path: path,\r\n                            value: target[i],\r\n                            object: observed.proxy\r\n                        });\r\n                    }\r\n                }\r\n\r\n                if (!ad) return;\r\n                if (ad.observers.size) {\r\n                    Gamepad.observer.callObservers(ad.observers, changes);\r\n                }\r\n                return observed.proxy;\r\n            },\r\n            splice: function proxiedSplice(target, observed) {\r\n                let ad = Gamepad.observer.getAncestorInfo(observed),\r\n                    spliceContent, spliceResult, changes = [],\r\n                    tmpObserved,\r\n                    startIndex, removed, inserted, splLen, tarLen = target.length;\r\n\r\n                spliceContent = Array.from(arguments);\r\n                spliceContent.splice(0, 2);\r\n                splLen = spliceContent.length;\r\n\r\n                for (let i = 2, item; i < splLen; i++) {\r\n                    item = spliceContent[i];\r\n                    if (item && typeof item === 'object' && !Gamepad.observer.nonObservables.hasOwnProperty(item\r\n                        .constructor.name)) {\r\n                        spliceContent[i] = Array.isArray(item) ?\r\n                            new Gamepad.ArrayObserver({\r\n                                target: item,\r\n                                ownKey: i,\r\n                                parent: observed\r\n                            }).proxy :\r\n                            new Gamepad.ObjectObserver({\r\n                                target: item,\r\n                                ownKey: i,\r\n                                parent: observed\r\n                            }).proxy;\r\n                    }\r\n                }\r\n\r\n                startIndex = splLen === 0 ? 0 : (spliceContent[0] < 0 ? tarLen + spliceContent[0] :\r\n                    spliceContent[0]);\r\n                removed = splLen < 2 ? tarLen - startIndex : spliceContent[1];\r\n                inserted = Math.max(splLen - 2, 0);\r\n                spliceResult = Reflect.apply(target.splice, target, spliceContent);\r\n                tarLen = target.length;\r\n\r\n                for (let i = 0, item; i < tarLen; i++) {\r\n                    item = target[i];\r\n                    if (item && typeof item === 'object') {\r\n                        tmpObserved = item[Gamepad['SYMBOL']];\r\n                        if (tmpObserved) {\r\n                            tmpObserved.ownKey = i;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let i, l, item;\r\n                for (i = 0, l = spliceResult.length; i < l; i++) {\r\n                    item = spliceResult[i];\r\n                    if (item && typeof item === 'object') {\r\n                        tmpObserved = item[Gamepad['SYMBOL']];\r\n                        if (tmpObserved) {\r\n                            spliceResult[i] = tmpObserved.revoke();\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!ad) return;\r\n                if (ad.observers.size) {\r\n                    let index, path;\r\n                    for (index = 0; index < removed; index++) {\r\n                        path = ad.path.slice(0);\r\n                        path.push(startIndex + index);\r\n                        if (index < inserted) {\r\n                            changes.push({\r\n                                type: Gamepad.observer.UPDATE,\r\n                                path: path,\r\n                                value: target[startIndex + index],\r\n                                oldValue: spliceResult[index],\r\n                                object: observed.proxy\r\n                            });\r\n                        } else {\r\n                            changes.push({\r\n                                type: Gamepad.observer.DELETE,\r\n                                path: path,\r\n                                oldValue: spliceResult[index],\r\n                                object: observed.proxy\r\n                            });\r\n                        }\r\n                    }\r\n                    for (; index < inserted; index++) {\r\n                        path = ad.path.slice(0);\r\n                        path.push(startIndex + index);\r\n                        changes.push({\r\n                            type: Gamepad.observer.INSERT,\r\n                            path: path,\r\n                            value: target[startIndex + index],\r\n                            object: observed.proxy\r\n                        });\r\n                    }\r\n                    Gamepad.observer.callObservers(ad.observers, changes);\r\n                }\r\n                return spliceResult;\r\n            }\r\n        }\r\n        if (proxiedArrayMethods.hasOwnProperty(key)) {\r\n            return proxiedArrayMethods[key].bind(undefined, target, this);\r\n        } else {\r\n            return target[key];\r\n        }\r\n    }\r\n}\r\n\r\n/* Object observer class */\r\n// observer for objects\r\nGamepad.ObjectObserver = class extends Gamepad.Observer {\r\n    constructor(properties) {\r\n        super(properties, Gamepad.observer.prepareObject);\r\n    }\r\n\r\n    // revoke the observer, now it will work as a normal object\r\n    revoke() {\r\n        // set isRevoked prop\r\n        this.isRevoked = true;\r\n\r\n        let target = this.target,\r\n            keys = Object.keys(target),\r\n            l = keys.length,\r\n            key, item;\r\n        // revoke each children\r\n        while (l--) {\r\n            key = keys[l];\r\n            item = target[key];\r\n            if (item && typeof item === 'object') {\r\n                let tmpObserved = item[Gamepad['SYMBOL']];\r\n                if (tmpObserved) {\r\n                    target[key] = tmpObserved.revoke();\r\n                }\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n}\r\n\r\n/* Gamepad Store */\r\n// this class manage the changes of a single observer\r\nGamepad.Store = class {\r\n    constructor(json) {\r\n        // the changes observer\r\n        this.observer = Gamepad.observer.observeJson(json);\r\n        // history of changes\r\n        this.history = [];\r\n        // history index\r\n        this.index = -1;\r\n        // current changes\r\n        this.changes = [];\r\n\r\n        // observe the json\r\n        this.observer.observe(changes => {\r\n            changes.forEach(change => {\r\n                //  update this part.\r\n                // the values are not saved directly because they can change\r\n                if ('value' in change && change.value != undefined)\r\n                    change.value = JSON.parse(JSON.stringify(change.value));\r\n\r\n                if ('oldValue' in change && change.oldValue != undefined)\r\n                    change.oldValue = JSON.parse(JSON.stringify(change.oldValue));\r\n\r\n                this.changes.push(change);\r\n            });\r\n        });\r\n    }\r\n\r\n    // commit changes\r\n    commit() {\r\n        // update the history\r\n        this.history.splice(this.index + 1);\r\n        this.history.push(this.changes);\r\n        this.index = this.history.length - 1;\r\n        // remove changes\r\n        this.changes = [];\r\n    }\r\n\r\n    // unload all changes that have not been committed\r\n    restore() {\r\n        let changes = this.changes.slice(0);\r\n        while (changes.length > 0)\r\n            Gamepad.observer.unloadChange(this.observer, changes.pop());\r\n\r\n        this.changes = [];\r\n    }\r\n\r\n    // load all changes\r\n    loadChanges() {\r\n        // remove useless changes\r\n        this.restore();\r\n\r\n        // if there are change to load\r\n        if (this.index < this.history.length - 1) {\r\n            // change store\r\n            this.index++;\r\n\r\n            let changes = this.history[this.index],\r\n                i = -1;\r\n\r\n            // load all changes\r\n            while (++i < changes.length)\r\n                Gamepad.observer.loadChange(this.observer, changes[i]);\r\n\r\n            // remove the changes that this process has created\r\n            this.changes = [];\r\n        }\r\n    }\r\n\r\n    // unload all changes\r\n    unloadChanges() {\r\n        // remove useless changes\r\n        this.restore();\r\n\r\n        // if there are changes to unload\r\n        if (this.index > -1) {\r\n            let changes = this.history[this.index],\r\n                i = changes.length;\r\n\r\n            // unload all changes\r\n            while (--i >= 0)\r\n                Gamepad.observer.unloadChange(this.observer, changes[i]);\r\n\r\n            // change store\r\n            this.index--;\r\n\r\n            // remove the changes that this process has created\r\n            this.changes = [];\r\n        }\r\n    }\r\n}\r\n\r\n/* Gamepad JsonManager */\r\n// this class manage multiple stores\r\nGamepad.JsonManager = class {\r\n    constructor(json) {\r\n        this.init(json || {});\r\n    }\r\n\r\n    // reset the stores\r\n    reset() {\r\n        this.init();\r\n    }\r\n\r\n    // init a new json\r\n    init(json) {\r\n        // update the old json\r\n        if (json !== undefined) this.json = json;\r\n\r\n        // stores\r\n        this.stores = [];\r\n        // stores index\r\n        this.index = 0;\r\n\r\n        // load the stores\r\n        if (Array.isArray(this.json)) {\r\n            for (let value of this.json)\r\n                this.stores.push(new Gamepad.Store(value));\r\n        } else {\r\n            this.stores.push(new Gamepad.Store(this.json));\r\n        }\r\n\r\n        // the stores should not be changed here\r\n        Object.freeze(this.stores);\r\n    }\r\n\r\n    // get the current store\r\n    get store() {\r\n        return this.stores[this.index];\r\n    }\r\n    // get the current observer\r\n    get observer() {\r\n        return this.store.observer;\r\n    }\r\n    // get the observers\r\n    get observers() {\r\n        return this.stores.map(store => store.observer);\r\n    }\r\n    // get the current history\r\n    get history() {\r\n        return this.store.history;\r\n    }\r\n    // get the current changes\r\n    get changes() {\r\n        return this.store.changes;\r\n    }\r\n    // set the current changes\r\n    set changes(changes) {\r\n        this.store.changes = changes;\r\n    }\r\n\r\n    // save changes\r\n    commit() {\r\n        this.store.commit();\r\n    }\r\n\r\n    // load all changes\r\n    loadChanges() {\r\n        this.store.loadChanges();\r\n    }\r\n\r\n    // unload all changes\r\n    unloadChanges() {\r\n        this.store.unloadChanges();\r\n    }\r\n\r\n    // load the next json\r\n    loadNext() {\r\n        if (this.index < this.stores.length - 1) this.index++;\r\n    }\r\n\r\n    // load the prior json\r\n    loadPrior() {\r\n        if (this.index > 0) this.index--;\r\n    }\r\n}\r\n\r\n/* Global */\r\n;(function () {\r\n\r\n    // Establish the root object, `window` in the browser, or `global` on the server.\r\n    var root = this;\r\n\r\n    // Export the Underscore object for **CommonJS**, with backwards-compatibility\r\n    // for the old `require()` API. If we're not in CommonJS\r\n    if (typeof module !== 'undefined' && module.exports) {\r\n        const Blockly = require('blockly');\r\n\r\n        module.exports = Gamepad;\r\n        root.Blockly = Blockly;\r\n        Blockly.Gamepad = Gamepad;\r\n    } else {\r\n        if(typeof Blockly !== undefined) \r\n            Blockly.Gamepad = Gamepad;\r\n    }\r\n})();\r\n\r\n/* load the setting */\r\nGamepad.setting();\r\n\r\n\r\n//export default Gamepad"]},"metadata":{},"sourceType":"script"}